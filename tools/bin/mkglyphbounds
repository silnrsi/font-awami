#!/usr/bin/env python3

import argparse
from fontTools import ttLib, ufoLib
from fontTools.pens.boundsPen import BoundsPen
from fontTools.pens.basePen import BasePen
from fontTools.misc.bezierTools import calcCubicParameters, solveCubic, solveQuadratic, cubicPointAtT
from dataclasses import dataclass
from typing import Tuple

@dataclass
class Curve:
    p0: Tuple[float, float]
    p1: Tuple[float, float]
    p2: Tuple[float, float]
    p3: Tuple[float, float]

    def calcRoots(self):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        dyroots = [t for t in solveQuadratic(3 * a[1], 2 * b[1], c[1]) if 0 <= t < 1]
        self.dyroots = [(t, 6 * a[1] * t + 2 * b[1], cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) for t in dyroots]

    def findT(self, x, upper=False):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        solutions = sorted(((t, cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) \
                for t in solveCubic(a[0], b[0], c[0], d[0] - x) if 0 <= t < 1),
                key=lambda x:(x[1], x[0]))
        if not len(solutions):
            return [None, None]
        return solutions[-1 if upper else 0]

    def hasRoots(self):
        return getattr(self, 'dyroots', None) is not None


class SlicePen(BoundsPen):

    def __init__(self, glyphSet):
        super().__init__(glyphSet)
        self.init()

    def init(self):
        self.curves = []
        self.bounds = None      # xMin, yMin, xMax, yMax

    def slices(self, width=50, rtl=False, upper=False):
        if not len(self.curves):
            return []
        if not self.curves[0].hasRoots():
            for c in self.curves:
                c.calcRoots()
        res = []
        xs = []
        endx = self.bounds[2]
        if rtl:
            x = endx
            while x >= 0:
                xs.append(x)
                x -= width
            if len(xs) and xs[-1] > 0:
                xs.append(0)
        else:
            x = 0
            while x <= endx:
                xs.append(x)
                x += width
            if len(xs) and xs[-1] < endx:
                xs.append(endx)
        if not len(xs):
            return []
        lastx = xs[0]
        for x in xs[1:]:
            res.append(self._calcSlice(lastx, x, upper=upper))
            lastx = x
        return res

    def _calcSlice(self, l, r, upper=False):
        if r < l:
            l, r = r, l
        if upper:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return max(a, b)
        else:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return min(a, b)

        res = None
        for c in self.curves:
            lt, ly = c.findT(l, upper=upper)
            rt, ry = c.findT(r, upper=upper)
            y = None
            if rt is not None and lt is not None:
                for root in c.dyroots:
                    if lt < root[0] < rt and (root[1] < 0 == upper):
                        y = root[2]
            if y is None:
                y = choose(ly, ry)
            res = choose(res, y)
        return res
        
    def _lineTo(self, p):
        super()._lineTo(p)
        self.curves.append(Curve(self._getCurrentPoint(), self._getCurrentPoint(), p, p))

    def _curveToOne(self, p1, p2, p3):
        super()._curveToOne(p1, p2, p3)
        self.curves.append(Curve(self._getCurrentPoint(), p1, p2, p3))

    def _qCurveToOne(self, p1, p2):
        super()._qCurveToOne(p1, p2)
        BasePen._qCurveToOne(self, p1, p2)

def procBounds(g, p, width):
    p.init()
    g.draw(p)
    uppers = p.slices(width, rtl=True, upper=True)
    lowers = p.slices(width, rtl=False, upper=False)
    return [uppers, lowers]

def str_flist(l):
    return ", ".join(["{:.2f}".format(x) for x in l if x is not None])

parser = argparse.ArgumentParser()
parser.add_argument("infont", help="Input font file")
parser.add_argument("-o", "--outfile", help="Output OpenType file")
parser.add_argument("-w", "--width", type=int, default=50, help="Slice width")
args = parser.parse_args()

if args.infont.lower().endswith(".ttf"):
    f = ttLib.TTFont(args.infont)
elif args.infont.lower().endswith(".ufo"):
    f = ufoLib.UFOReader(args.infont)
gs = f.getGlyphSet()
pen = SlicePen(gs)
with open(args.outfile, "w") as outf:
    for gn in gs.keys():
        g = gs[gn]
        # if gn in ("absTahIni.sn", "absAin"):
            # breakpoint()
        u, l = procBounds(g, pen, args.width)
        outf.write(f"{gn}: u=[{str_flist(u)}], l=[{str_flist(l)}]\n")


