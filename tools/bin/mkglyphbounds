#!/usr/bin/env python3

# Run this script from the tools/bin directory where the file is located:
#    ./mkglyphbounds -o ../../source/opentype/autoKernMetrics.feax ../../source/masters/AwamiNastaliq-Regular.ufo

import argparse
from fontTools import ttLib, ufoLib
from fontTools.pens.boundsPen import BoundsPen
from fontTools.pens.basePen import BasePen
from fontTools.misc.bezierTools import calcCubicParameters, solveCubic, solveQuadratic, cubicPointAtT
from fontParts.world import *
from dataclasses import dataclass
from typing import Tuple


# increment that we're using:
INCREMENT = 100

@dataclass
class Curve:
    p0: Tuple[float, float]
    p1: Tuple[float, float]
    p2: Tuple[float, float]
    p3: Tuple[float, float]

    def calcRoots(self):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        dyroots = [t for t in solveQuadratic(3 * a[1], 2 * b[1], c[1]) if 0 <= t < 1]
        self.dyroots = [(t, 6 * a[1] * t + 2 * b[1], cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) for t in dyroots]

    def findT(self, x, upper=False):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        solutions = sorted(((t, cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) \
                for t in solveCubic(a[0], b[0], c[0], d[0] - x) if 0 <= t < 1),
                key=lambda x:(x[1], x[0]))
        if not len(solutions):
            return [None, None]
        return solutions[-1 if upper else 0]

    def hasRoots(self):
        return getattr(self, 'dyroots', None) is not None

# end of  class Curve

class SlicePen(BoundsPen):

    def __init__(self, glyphSet):
        super().__init__(glyphSet)
        self.init()

    def init(self):
        self.curves = []
        self.bounds = None      # xMin, yMin, xMax, yMax

    def slices(self, width=INCREMENT, rtl=False, upper=False):
        if not len(self.curves):
            return []
        if not self.curves[0].hasRoots():
            for c in self.curves:
                c.calcRoots()
        res = []
        xs = []
        endx = self.bounds[2]
        if rtl:
            x = endx
            while x >= 0:
                xs.append(x)
                x -= width
            if len(xs) and xs[-1] > 0:
                xs.append(0)
        else:
            x = 0
            while x <= endx:
                xs.append(x)
                x += width
            if len(xs) and xs[-1] < endx:
                xs.append(endx)
        if not len(xs):
            return []
        lastx = xs[0]
        for x in xs[1:]:
            res.append(self._calcSlice(lastx, x, upper=upper))
            lastx = x
        return res

    def _calcSlice(self, l, r, upper=False):
        if r < l:
            l, r = r, l
        if upper:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return max(a, b)
        else:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return min(a, b)

        res = None
        for c in self.curves:
            lt, ly = c.findT(l, upper=upper)
            rt, ry = c.findT(r, upper=upper)
            y = None
            if rt is not None and lt is not None:
                for root in c.dyroots:
                    if lt < root[0] < rt and (root[1] < 0 == upper):
                        y = root[2]
            if y is None:
                y = choose(ly, ry)
            res = choose(res, y)
        return res
        
    def _lineTo(self, p):
        super()._lineTo(p)
        self.curves.append(Curve(self._getCurrentPoint(), self._getCurrentPoint(), p, p))

    def _curveToOne(self, p1, p2, p3):
        super()._curveToOne(p1, p2, p3)
        self.curves.append(Curve(self._getCurrentPoint(), p1, p2, p3))

    def _qCurveToOne(self, p1, p2):
        super()._qCurveToOne(p1, p2)
        BasePen._qCurveToOne(self, p1, p2)

# end of class SlicePen


def ProcBounds(g, p, width):
    p.init()
    g.draw(p)
    # All values should be in logical order, RTL:
    uppers = p.slices(width, rtl=True, upper=True)
    lowers = p.slices(width, rtl=True, upper=False)
    return [uppers, lowers]


def CalcExitsAndRiseValues(font):

    # These must match what are in genArithmeticLookups.py
    dyMin = -300  # perhaps change to -700 for eg, absSadMed.benn, absHehGoalMed.benn, absTahMed, absFehMed.benn, absAinMed, etc.
    dyMax = 3000

    riseValues = {}
    exits = {}
    for glyph in font:
        gn = glyph.name
        if isArabicBase(gn):
            if isInitialBase(gn) or isMedialBase(gn) or isFinalBase(gn):
                yEntry = None
                yExit = 0 if isFinalBase(gn) else None
                anchorList = glyph.anchors
                for anchor in anchorList:
                    if anchor.name == "entry":
                        yEntry = anchor.y
                    elif anchor.name == "exit":
                        yExit = anchor.y

                if yExit is None:
                    print("WARNING: missing EXIT for " + gn)
                exits[gn] = yExit

                if isMedialBase(gn) or isFinalBase(gn):
                    if yEntry is None:
                        print("WARNING: missing ENTRY for " + gn)
                        dy = 0
                    else:
                        dy = yEntry - yExit
                    dy = max(min(dyMax, dy), dyMin)
                    riseValues[gn] = dy
            else:
                exits[gn] = 0   # isolate

        # else ignore this glyph

    return [exits, riseValues]

# end of CalcExitsAndRiseValues


def MakeRelativeToExit(exit, vList):
    if exit is None: # final, isolate
        return vList
    res = []
    for v in vList:
        if v is not None:
            res.append(v - exit)
    return res


def MarkerValue(v, inc, prefix):
	if prefix == "asc":
		v += 50
	elif prefix == "dsc":
		v -= 50
	roundedV = round(v / inc) * inc
	if roundedV < 0:
		result = "N" + str(abs(roundedV))
	else:
		result = str(roundedV)
	while (len(result) < 6):
		result += " "
	return result
# end of MarkerValue


def FormatMarkerList(vList, prefix, sliceWidth):
    # prefix = 'asc' or 'dsc'

    #return ", ".join(["{:.2f}".format(x) for x in vList if x is not None])

    # Must match what's in genArithmeticLookups.py
    ascMin = -500
    ascMax = 3000
    dscMin = -1500
    dscMax = 3000

    vMin = ascMin if prefix == "asc" else dscMin
    vMax = ascMax if prefix == "asc" else dscMax

    result = ""
    for v in vList:
        if v is not None:
            v = max(min(v, vMax), vMin)
            result += prefix + MarkerValue(v, sliceWidth, prefix)
    return result


def isArabicBase(name):
    
    allBases = ["absAlef", "absHighHamzaAlef",
        "absBeh", "absTeh", "absTheh", "absPeh", "absTte", "absBeeh", "absDotlessBeh",
        "absJeem", "absHah", "absKhah", "absTcheh", "absNyeh", "absDyeh",
        "absSeen", "absSheen", 
        "absSad", "absDad",
        "absTah", "absZah",
        "absAin", "absGhain",
        "absFeh", "absQaf", "absVeh", "absDotlessFeh", "absDotlessQaf",
        "absKeheh", "absKaf", "absGaf", "absGueh", "absNgoeh", "absGraf", 
        "absLam",
        "absMeem",
        "absNoon", "absRnoon", 
        "absHehDoach",
        "absHehGoal", "absTehMarbuta", "absHeh", "absAe",
        "absDal", "absThal", "absDdal", "absDul",
        "absReh", "absZain", "absJeh", "absRreh",
        "absWaw", "absU", "absOe", "absKirghiz", "absVe", "absYu",
        "absYeh", "nlqChotiyeh", "absE", "absAlefMaksura", "absKashmiriYeh",
        "nlqBariyeh",
        "absLigatureAllah", "absLigatureLlah"];
    
    if name == "absVerseSign": # triggered by absVe
        return False
    elif name == "absEmptyCentreLowStop": # triggered by absE
        return False
    elif "absEndOfAyah" in name:
        return False
    elif "absEastern" in name:
        return False
    elif "absEight" in name:
        return False
    elif name == "absNoonGhunnaMark":   # triggered by absNoon
        return False
    
    # TODO: ignore digits, if necessary

    for baseName in allBases:
        if name[0:len(baseName)] == baseName:
            return True
    return False

# end of isArabicBase

def isInitialBase(name):
    if ("Ini" in name): return True
    return False

def isMedialBase(name):
    if ("Med" in name): return True
    return False

def isFinalBase(name):
    if ("Fin" in name): return True
    return False

def isIsolateFinalBase(name):
    if ("Ini" in name): return False
    if ("Med" in name): return False
    if name == "absNoonGhunnaMark": return False
    return True

def isKernableBase(name):
    return isIsolateFinalBase(name)

def EntryInterface(gn):
    if "Med" in gn or "Fin" in gn:
        if "Alef" in gn:
            return "default"
        elif "Beh" in gn:
            if gn == "absBehFin":
                return "beF"
            elif gn == "absBehMed.beM2" or gn == "absBehMed.be" or gn == "absBehMed.behg" or gn =="absBehMed.sn" \
                    or gn == "absBehMed.snR" or gn == "absBehMed.snsn":
                return "beM1"
            elif gn == "absBehMed.beM1":
                return "beM2"
            elif "absBehMed.nn" in gn:  # absBehMed.nnR, absBehMed.nn_hgbm, etc.
                return "benn"
            elif gn == "absBehMed.re":
                return "bere"
            elif gn == "absBehMed.hg":
                return "behg"
            else:
                return "be"
        elif "Jeem" in gn:
            return "jm"
        elif "Seen" in gn:
            if gn == "absSadMed.sn":
                return "snsn"
            else:
                return "sn"
        elif "Sad" in gn:
            return "sd"
        elif "Tah" in gn:
            return "ta"
        elif "Ain" in gn:
            return "ai"
        elif "Feh" in gn:
            return "fe"
        elif "Keheh" in gn or "Gaf" in gn:
            if gn == "absKehehMed" or gn == "absGafMed":
                return "sd"
            else:
                return "default"
        elif "Lam" in gn:
            return "default"
        elif "Meem" in gn:
            if gn =="absMeemMed.alt":
                return "mmX"
            else:
                return "mm"
        elif "Noon" in gn:
            return "nn"
        elif "HehDoachashmee" in gn:
            return "hd"
        elif "HehGoal" in gn:
            if gn == "absHehGoalFin":
                return "hgF"
            else:
                return "hgM"
        elif "Qaf" in gn or "Waw" in gn:
            return "qf"
        elif "Reh" in gn:
            return "re"
        elif "Dal" in gn:
            return "default"
        elif "Chotiyeh" in gn:
            return "ch"
        elif "Bariyeh" in gn:
            return "by"
    else:
        return None

# end of EntryInterface

def ExitInterface(gn):
    # Note: for our purposes we don't need to distinguish between the multiple re, ch, and qf interfaces;
    # their adjustments are all the same.
    labels = ["benn", "bere", "behg", "beM1", "beM2", "beF", "be", "jm", "snsn", "sn", "sd", "ta", "ai", "fe", "mm", "mmX",
                  "nn", "hd", "hgM", "hgF", "qf", "re", "ch", "by"]
    if "Ini" in gn or "Med" in gn:
        for label in labels:
            suffix = "." + label
            if suffix in gn:
                return label
        return "default"
    else:
        return None

# end of ExitInterface


def TrimMetrics(gname, uppers, lowers, entry, exit, sliceWidth):
    # Note: metrics are in RTL order.

    # TODO: rewrite to take various values of sliceWidth into account.
    # Right now we assume 100.

    # Remove None elements so our counting is correct.
    t = []
    for lower in lowers:
        if lower is not None:
            t.append(lower)
    lowers = t

    # These interfaces overlap such that the right-hand glyph is underneath.
    # Trim off the end of the upper metrics on the right-hand (exit) glyph
    # and the beginning of the lower metrics on the left-hand (entry) glyph.

    if entry == "default":
        # Remove slices from right end of lowers
        if "absAlef" in gname:
            lowers = lowers[3:]  # all of them for absAlefFin - is this a problem?
        elif "absLam" in gname:
            lowers = lowers[1:]
        elif "absKeheh" in gname or "absGaf" in gname:
            # trim off the diagonal stroke:
            lowers = lowers[10:]
        elif "absDal" in gname:
            lowers = lowers[1:]
    if exit == "default":
        uppers = uppers[0:-2]  # remove 200 from left end of lowers

    if entry == "ai":
        lowers = lowers[2:]
    if exit == "ai":
        uppers = uppers[0:-2]

    if entry == "benn":
        lowers = lowers[2:]
    if exit == "benn":
        uppers = uppers[0:-2]

    if entry == "beF":
        lowers = lowers[1:]
    if exit == "beF":
        uppers = uppers[0:-1]

    if entry == "fe":
        lowers = lowers[2:]  # 250 units
    if exit == "fe":
        uppers = uppers[0:-2]

    if entry == "sd":
        lowers = lowers[5:]
    if exit == "sd":
        uppers = uppers[0:-5]  # 550 units

    if entry == "ta":
        lowers = lowers[7:]
    if exit == "ta":
        uppers = uppers[0:-7]

    if entry == "by":
        uppers = uppers[0:1]
        
    # These interfaces overlap such that the right-hand glyph is on top.
    # Trim off the end of the lower metrics on the right-hand (exit) glyph
    # and the beginning of the upper metrics on the left-hand (entry) glyph.

    if entry == "beM1":
        uppers = uppers[1:]
    if exit == "beM1":
        lowers = lowers[0:-1]

    if entry == "ch":
        uppers = uppers[5:]
    if exit == "ch":
        lowers = lowers[0:-5]

    if entry == "hd":
        uppers = uppers[4:]
    if exit == "hd":
        lowers = lowers[0:-4]

    if entry == "jm":
        uppers = uppers[7:]
    if exit == "jm":
        lowers = lowers[0:-7]

    if entry == "mm":
        uppers = uppers[5:]
    if exit == "mm":
        lowers = lowers[0:-5]

    if entry == "mmX":
        uppers = uppers[3:]
    if exit == "mmX":
        lowers = lowers[0:-3]

    # Only overlaps at very top.

    if exit == "nn":
        uppers = uppers[0:-1]

    return [uppers, lowers]

# end of TrimMetrics


def TruncateLowFinals(lowers):
    # Once the bottom of a final or isolate gets below -400, it will block kerning,
    # so truncate the marker stream in order to minimize the number of markers.

    if not lowers: # empty
        return lowers
    
    result = []
    for v in lowers:
        if v is not None:
            result.append(v)
            if v < -400 and len(result) > 1:
                return result

    return result

# end of TruncateLowFinals


# Hard code some special cases.
def Tweak(gn, uppers, lowers):
    if gn == "absReh" or gn == "absRehFin._jkl" or gn == "absRehFin":
        # The left-hand point of these rehs needs more space.
        uppers[-4] = 400
        uppers[-3] = 400
        uppers[-2] = 400
        uppers[-1] = 200
    elif gn == "absRehFin._hgM":
        uppers[-2] = 400
        uppers[-1] = 200

    kafIsolates = ["absKeheh", "absKaf", "absKafRing", "absKafTwoDotsAbove", "absKafThreeDotsAbove", "absKehehDotAbove",
                   "absKehehThreeDotsAbove", "absGaf", "absGueh", "absNgoeh", "absGraf"]

    if gn in kafIsolates or "absKehehIni" in gn or "absGafIni" in gn:
        if gn == "absKehehIni" or gn == "absGafIni": # round forms
            pass
        elif "_base" in gn:
            pass
        elif gn == "absKehehIni.ch" or gn == "absGafIni.ch" or gn == "absKehehIni.hd" or gn == "absGafIni.hd":
            pass
        elif gn == "absKehehIni.mm" or gn == "absGafIni.mm" or gn == "absKehehIni.mm_short" or gn =="absGafIni.mm_short":
            pass
        else:  
            # The bottom corner of the vertical stroke needs more space.
            # PrintList(gn, lowers)
            lowers[5] = 600  # normally something like 1400
            lowers[6] = 400
            lowers[7] = 100
            lowers[8] = 0

    return [uppers, lowers]



def PrintList(gn, vList):

    if not vList:
        print(gn + ": list is empty")
        return
    
    #str = ", ".join(["{:.2f}".format(x) for x in vList if x is not None])

    str = ""
    for v in vList:
        if v is None:
            str += " None"
        else:
            str += "  " + "{:.2f}".format(v)
    print(gn + ": " + str)


#=====  MAIN ROUTINE  =====

parser = argparse.ArgumentParser()
parser.add_argument("infont", help="Input font file")
parser.add_argument("-o", "--outfile", help="Output OpenType file")
parser.add_argument("-w", "--width", type=int, default=INCREMENT, help="Slice width")
args = parser.parse_args()

if args.infont.lower().endswith(".ttf"):
    f = ttLib.TTFont(args.infont)
    riseValues = {}
    print("Warning: delta-y values cannot be calculated from a TTF file - all the values will be zero.")
    skipglyphset = []
elif args.infont.lower().endswith(".ufo"):
    f = ufoLib.UFOReader(args.infont)
    fFtools = OpenFont(args.infont)
    exits, riseValues = CalcExitsAndRiseValues(fFtools)
    skipglyphset = set(fFtools.lib.get('public.skipExportGlyphs', []))

sliceWidth = args.width

gs = f.getGlyphSet()
pen = SlicePen(gs)

with open(args.outfile, "w") as outf:
    outf.write("# This file was generated by the mkglyphbounds script.\n")
    outf.write("# It contains metric values to use in auto-kerning.\n\n")
    outf.write("lookup InitKernMetrics {\n\n")

    for gn in gs.keys():
        if isArabicBase(gn) and gn not in skipglyphset:
            g = gs[gn]
            # if gn in ("absTahIni.sn", "absAin"):
                # breakpoint()

            uppers, lowers = ProcBounds(g, pen, sliceWidth)

            uppers = MakeRelativeToExit(exits[gn], uppers)
            lowers = MakeRelativeToExit(exits[gn], lowers)

            # Trim off some of the slice metrics to account for the fact that glyphs
            # overlap when they connect. The interface indicates (roughly) how much
            # overlap there is.
            entry = EntryInterface(gn)
            exit = ExitInterface(gn)
            #entry = "None" if entry is None else entry
            #exit = "None" if exit is None else exit
            #print(gn + ": " + entry + " / " + exit)
            # if exit is None and isIsolateFinalBase(name): 
            #     PrintList(gn, lowers)

            uppers, lowers = TrimMetrics(gn, uppers, lowers, entry, exit, sliceWidth)

            # if gn == "absMeemMed.sn":
            #     PrintList(gn, lowers)

            if exit is None and isIsolateFinalBase(gn): 
                # PrintList(gn, lowers)
                lowers = TruncateLowFinals(lowers)

            #uppers, lowers = TruncateLongSeq(uppers, lowers)

            uppers, lowers = Tweak(gn, uppers, lowers)

            #gnMarker = BaseMarkerName(gn)
            gnMarker = gn

            rise = riseValues[gn] if gn in riseValues else None
            dy = "dy0" if rise is None else "dy" + MarkerValue(rise, 100, "dy")
            py = "py0" if isIsolateFinalBase(gn) else "pyNULL"
            kw = "\n\t\t\t\t\tkw0" if isKernableBase(gn) else ""
            dscString = FormatMarkerList(lowers, "dsc", sliceWidth)
            ascString = FormatMarkerList(uppers, "asc", sliceWidth)

            outf.write(f"  sub {gn}  by  {gnMarker}  {dy}  {py}  \n\t\t\t\t\t{dscString}\tybLast\n\t\t\t\t\t{ascString}{kw};\n")

    outf.write("\n} InitKernMetrics;\n")

print("Output written to " + args.outfile)
