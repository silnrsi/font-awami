#!/usr/bin/env python3

# Run this script from the tools/bin directory where the file is located:
#    ./mkglyphbounds -o ../../source/opentype/autoKernMetrics.feax ../../source/masters/AwamiNastaliq-Regular.ufo

import argparse
from fontTools import ttLib, ufoLib
from fontTools.pens.boundsPen import BoundsPen
from fontTools.pens.basePen import BasePen
from fontTools.misc.bezierTools import calcCubicParameters, solveCubic, solveQuadratic, cubicPointAtT
from fontParts.world import *
from dataclasses import dataclass
from typing import Tuple



# increment that we're using:
inc = 100

@dataclass
class Curve:
    p0: Tuple[float, float]
    p1: Tuple[float, float]
    p2: Tuple[float, float]
    p3: Tuple[float, float]

    def calcRoots(self):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        dyroots = [t for t in solveQuadratic(3 * a[1], 2 * b[1], c[1]) if 0 <= t < 1]
        self.dyroots = [(t, 6 * a[1] * t + 2 * b[1], cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) for t in dyroots]

    def findT(self, x, upper=False):
        a, b, c, d = calcCubicParameters(self.p0, self.p1, self.p2, self.p3)
        solutions = sorted(((t, cubicPointAtT(self.p0, self.p1, self.p2, self.p3, t)[1]) \
                for t in solveCubic(a[0], b[0], c[0], d[0] - x) if 0 <= t < 1),
                key=lambda x:(x[1], x[0]))
        if not len(solutions):
            return [None, None]
        return solutions[-1 if upper else 0]

    def hasRoots(self):
        return getattr(self, 'dyroots', None) is not None

# end of  class Curve

class SlicePen(BoundsPen):

    def __init__(self, glyphSet):
        super().__init__(glyphSet)
        self.init()

    def init(self):
        self.curves = []
        self.bounds = None      # xMin, yMin, xMax, yMax

    def slices(self, width=50, rtl=False, upper=False):
        if not len(self.curves):
            return []
        if not self.curves[0].hasRoots():
            for c in self.curves:
                c.calcRoots()
        res = []
        xs = []
        endx = self.bounds[2]
        if rtl:
            x = endx
            while x >= 0:
                xs.append(x)
                x -= width
            if len(xs) and xs[-1] > 0:
                xs.append(0)
        else:
            x = 0
            while x <= endx:
                xs.append(x)
                x += width
            if len(xs) and xs[-1] < endx:
                xs.append(endx)
        if not len(xs):
            return []
        lastx = xs[0]
        for x in xs[1:]:
            res.append(self._calcSlice(lastx, x, upper=upper))
            lastx = x
        return res

    def _calcSlice(self, l, r, upper=False):
        if r < l:
            l, r = r, l
        if upper:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return max(a, b)
        else:
            def choose(a, b):
                if a is None:
                    return b
                elif b is None:
                    return a
                return min(a, b)

        res = None
        for c in self.curves:
            lt, ly = c.findT(l, upper=upper)
            rt, ry = c.findT(r, upper=upper)
            y = None
            if rt is not None and lt is not None:
                for root in c.dyroots:
                    if lt < root[0] < rt and (root[1] < 0 == upper):
                        y = root[2]
            if y is None:
                y = choose(ly, ry)
            res = choose(res, y)
        return res
        
    def _lineTo(self, p):
        super()._lineTo(p)
        self.curves.append(Curve(self._getCurrentPoint(), self._getCurrentPoint(), p, p))

    def _curveToOne(self, p1, p2, p3):
        super()._curveToOne(p1, p2, p3)
        self.curves.append(Curve(self._getCurrentPoint(), p1, p2, p3))

    def _qCurveToOne(self, p1, p2):
        super()._qCurveToOne(p1, p2)
        BasePen._qCurveToOne(self, p1, p2)

# end of class SlicePen


def procBounds(g, p, width):
    p.init()
    g.draw(p)
    # All values should be in logical order, RTL:
    uppers = p.slices(width, rtl=True, upper=True)
    lowers = p.slices(width, rtl=True, upper=False)
    return [uppers, lowers]


def CalcRiseValues(font):
    result = {}
    for glyph in font:
        gn = glyph.name
        if arabicBase(gn):
            yEntry = None
            yExit = 0
            yBotRt = None
            anchorList = glyph.anchors
            for anchor in anchorList:
                if anchor.name == "entry":
                    yEntry = anchor.y
                elif anchor.name == "exit":
                    yExit = anchor.y
                elif anchor.name == "botRt":
                    yBotRt = anchor.y
            
            if yEntry == None:
                if yBotRt == None:
                    dy = 0
                else:
                    dy = yBotRt - yExit
            else:
                dy = yEntry - yExit
            result[gn] = dy
    return result

# end of CalcRiseValues


def MarkerValue(v):
	roundedV = round(v / inc) * inc
	if v < 0:
		result = "N" + str(abs(roundedV))
	else:
		result = str(roundedV)
	while (len(result) < 6):
		result += " "
	return result
# end of MarkerValue


def str_flist(vList, prefix):
    #return ", ".join(["{:.2f}".format(x) for x in vList if x is not None])

    result = ""
    for v in vList:
        if v is not None:
            result += prefix + MarkerValue(v)
    return result


def arabicBase(name):
    
    # What about bariyeh? For now we're ignoring it.
    allBases = ["absAlef", "absHighHamzaAlef",
        "absBeh", "absTeh", "absTheh", "absPeh", "absTte", "absBeeh", "absDotlessBeh",
        "absJeem", "absHah", "absKhah", "absTcheh", "absNyeh", "absDyeh",
        "absSeen", "absSheen", 
        "absSad", "absDad",
        "absTah", "absZah",
        "absAin", "absGhain",
        "absFeh", "absQaf", "absVeh", "absDotlessFeh", "absDotlessQaf",
        "absKeheh", "absKaf", "absGaf", "absGueh", "absNgoeh", "absGraf", 
        "absLam",
        "absMeem",
        "absNoon", "absRnoon", 
        "absHehDoach",
        "absHehGoal", "absTehMarbuta", "absHeh", "absAe",
        "absDal", "absThal", "absDdal", "absDul",
        "absReh", "absZain", "absJeh", "absRreh",
        "absWaw", "absU", "absoe", "absKirghiz", "absVe", "absYu",
        "absYeh", "nlqChotiyeh", "absE", "absAlefMaksura", "absKashmiriYeh",
        "absLigatureAllah", "absLigatureLlah"];
    
    if name == "absVerseSign": # triggered by absVe
        return False

    for baseName in allBases:
        if name[0:len(baseName)] == baseName:
            return True
    return False

def isFinalBase(name):
    return ("Fin" in name)

def isKernableBase(name):
    if ("Ini" in name): return False
    if ("Med" in name): return False
    return True


#=====  MAIN ROUTINE  =====

parser = argparse.ArgumentParser()
parser.add_argument("infont", help="Input font file")
parser.add_argument("-o", "--outfile", help="Output OpenType file")
parser.add_argument("-w", "--width", type=int, default=50, help="Slice width")
args = parser.parse_args()

if args.infont.lower().endswith(".ttf"):
    f = ttLib.TTFont(args.infont)
    riseValues = {}
    print("Warning: delta-y values cannot be calculated from a TTF file - all the values will be zero.")
elif args.infont.lower().endswith(".ufo"):
    f = ufoLib.UFOReader(args.infont)
    fFtools = OpenFont(args.infont)
    riseValues = CalcRiseValues(fFtools)

gs = f.getGlyphSet()
pen = SlicePen(gs)

with open(args.outfile, "w") as outf:
    outf.write("# This file was generated by the mkglyphbounds script.\n")
    outf.write("# It contains metric values to use in auto-kerning.\n\n")
    outf.write("lookup InitKernMetrics {\n\n")

    for gn in gs.keys():
        if arabicBase(gn):
            g = gs[gn]
            # if gn in ("absTahIni.sn", "absAin"):
                # breakpoint()
            u, l = procBounds(g, pen, args.width)
            #gnMarker = BaseMarkerName(gn)
            gnMarker = gn
            rise = riseValues[gn] if gn in riseValues else None
            dy = "dy0" if rise is None else "dy" + MarkerValue(rise)
            px = "px0" if isFinalBase(gn) else "pxNULL"
            kw = "\n\t\t\t\t\tkw0" if isKernableBase(gn) else ""
            outf.write(f"  sub {gn}  by  {gnMarker}  {dy}  {px}  \n\t\t\t\t\t{str_flist(l, "dsc")}\n\t\t\t\t\t{str_flist(u, "asc")}{kw};\n")

    outf.write("\n} InitKernMetrics;\n")

print("Output written to " + args.outfile)
