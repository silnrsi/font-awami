#!/usr/bin/python3

# Outputs a set of rules that defines some metrics for base glyphs that
# can be used to perform kerning.

# Run this script from the tools/scripts directory where the file is located:
#		python3 genMetrics4AutoKern.py

# The output looks like:
#		lookup InsertKernMetrics {
#			sub <glyphname>	by	<glyphname>	pxNULL	pyNULL	<advwidth>	<rise>	<xMin>	<xMax>;
#		}


from fontParts.world import *
import sys

#inc = 50
inc = 100

def FormatName(gname):
	cc = len(gname);
	result = gname
	while len(result) < 29:
		result += " "
	return result
# end of FormatName	

def FormatNumber(v):
	result = str(v)
	while len(result) < 6:
		result = " " + result
	return result
# end of FormatNumber

def MarkerValue(v):
	roundedV = round(v / inc) * inc
	if v < 0:
		result = "N" + str(abs(roundedV))
	else:
		result = str(roundedV)
	while (len(result) < 6):
		result += " "
	return result
# end of MarkerValue

# -----------------------------
# Main routine

# Open UFO
#ufo = sys.argv[1]
ufo = '../../source/masters/AwamiNastaliq-Regular.ufo'
font = OpenFont(ufo)

outfile = "../../source/opentype/autoKernMetrics.feax"
fout = open(outfile, 'w');

print()

skipglyphset = set(font.lib.get('public.skipExportGlyphs', []))

print("# This file was generated by the genMetrics4AutoKern.py script.", file=fout)
print("# It contains metric values to use in auto-kerning.\n\n", file=fout)

#print("#                                                                         ... place-holders ...    rise     descent   ascent", file=fout)
print("lookup InitKernMetrics {", file=fout)

cnt = 0;

glyphDict = {}

for glyph in font:
	aw = glyph.width
	gname = glyph.name
	if gname in skipglyphset:
		continue

	#if gname != "absHehDoachashmeeIni.bere_alt":
	#	continue
		
	if gname[0:3]== "abs" or gname[0:3] == "nlq":
		fInitial = gname[-3:] == "Ini" or "Ini." in gname or "Ini_" in gname
		fMedial = gname[-3:] == "Med" or "Med." in gname or "Med_" in gname
		fFinal = gname[-3:] == "Fin" or "Fin." in gname or "Fin_" in gname
		if fInitial or fMedial or fFinal:
			# Initial, medial, or final base that we're interested in.
			print(glyph.name)
			aw = glyph.width
			anchorList = glyph.anchors
			yMin = 5000
			yMax = -5000
			xEntry = yEntry = 1000
			if fFinal:
				xExit = 0
				yExit = 0
			for anchor in anchorList:
				aName = anchor.name
				if aName == "entry" or aName == "botRt":
					xEntry = anchor.x
					yEntry = anchor.y
				elif aName == "exit":
					xExit = anchor.x
					yExit = anchor.y
				
				if aName == "n1Lower" or aName == "n23Lower" or aName == "mLower"  or aName == "mLowerC" or aName == "hehhook":
					if yMin > anchor.y: yMin = anchor.y

				if aName == "nUpper" or aName == "mUpper" or aName == "mTahUpper":
					if yMax < anchor.x: yMax = anchor.y
			
			descent = yMin - yExit
			ascent = yMax - yExit

			#bottom = int(glyph.bottomMargin)
			if yEntry < 1000:
				print("  entry: (" + str(xEntry) + ", " + str(yEntry) + ")" )
			print("  exit: (" + str(xExit) + ", " + str(yExit) + ")" )
			print("  yMin: " + str(descent) + " -> " + MarkerValue(descent))
			print("  yMax: " + str(ascent) + " -> " + MarkerValue(ascent))
			#print("  bottom: " + str(bottom))

			rise = yEntry - yExit
			print("  rise: " + str(rise) + " -> " + MarkerValue(rise))

			glyphDict[glyph.name] = (aw, rise, descent, ascent)

		cnt += 1
		
		#if cnt > 25:
		#	break

	# for glyphs with abs or nlq
# end of for glyphs

gSorted = sorted(glyphDict.items())
for gName, values in gSorted:
	formattedName = FormatName(gName)
	aw = values[0]
	rise = values[1]
	descent = values[2]
	ascent = values[3]

	cStrips = round(aw/inc)
	stripMarkers = ""
	for i in range(cStrips):
		stripMarkers += "  yt" + MarkerValue(ascent)
	if fFinal:
		# don't bother with heights below
		stripMarkers += "  yb0"
	else:
		for i in range(cStrips):
			stripMarkers += "  yb" + MarkerValue(descent)

	# output aw as a comment

	print("\tsub " + formattedName + "\tby\t" + formattedName \
	   		### + " pxNULL  pyNULL  pxfNULL " \
	 		+ " dy" + MarkerValue(rise) + stripMarkers + ";", file=fout)

# end for glyphDict

print("} InitKernMetrEics;", file=fout)

print("Results written to " + outfile)

fout.close()

font.close()
