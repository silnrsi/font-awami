#!/usr/bin/python3

# Outputs a set of rules to perform bariyeh tail kerning.

# Run this script from the tools/scripts directory where the file is located:
#		python3 genBariyehKernRules.py

# When run in "pos" mode, the output assumes a set of kerning lookups such as:
#		lookup _Kern150 { pos @AllBases 150; } _Kern150;
# etc.
#
# When run in "sub" mode, it assumes a set of lookups such as:
#		lookup _InsSp2Kern150 { sub @Initials by sp150 @Initials } _InsSp2Kern150;
# etc.

# This version of the script assumes 5 width classes. At this point that number seems
# like the best bang for buck.

mode = "sub"
#mode = "pos"

import sys

def ExpandSeq(mode, seqSoFar, slotTotal, depth):
	#print("ExpandSeq" + " " + str(slotTotal) + " depth=" + str(depth))
	#print(seqSoFar)
	
	if len(seqSoFar) >= slotTotal:
		needed = OutputRuleIfNeeded(mode, seqSoFar)
		return needed
	else:
		for wc in range(numClasses):
			nextSeq = seqSoFar.copy()
			nextSeq.append(wc)
			#print("nextSeq=")
			#print(nextSeq)
			needed = ExpandSeq(mode, nextSeq, slotTotal, depth+1)
			#print("return to ExpandSeq depth " + str(depth))
			# if not needed:
			# 	return True		# nothing more is needed for this sequence, but something might be needed for another
		return True
		
# end of ExpandSeq

def OutputRuleIfNeeded(mode, seq):
	print("OutputRuleIfNeeded")
	print(seq)
	totalWidth = 0
	
	if seq[0] == 0:
		return True;	# don't bother with KZeroIni, since the class is empty
		
	if TooManyZeroSlots(seq):
		return True;
		
	for w in seq:
		totalWidth += TypicalWidth(w)
	#print("totalWidth=" + str(totalWidth))
	if totalWidth < BariyehWidth:
		kernValue = BariyehWidth - totalWidth
		OutputRule(mode, seq, kernValue)
		#OutputTextString(seq)
		#print("return True")
		return True
	else:
		#print("return False")
		# Prevent kerning under the first char, because there is a good chance that the
		# bariyeh is underneath it.
		if totalWidth - BariyehWidth < 1000:
			OutputRule(mode, seq, "prevent")

		return False

# end of OutputRuleIfNeeded

def OutputRule(mode, seq, kernValue):
	outputStr = mode + " ";
	first = True
	suffix = "Ini"
	for slot in seq:
		c = ClassName(slot) + suffix
		outputStr += "@" + c
		if first:
			outputStr += "' lookup "
			if kernValue == "prevent":
				outputStr += "_PreventKernUnder "
			else:
				if mode == "sub":
					outputStr += "_InsSp2Kern"
				else:
					outputStr += "_Kern"
				outputStr += str(kernValue) + "  "
		first = False
		suffix = "Med  "
	outputStr += "nlqBariyehFin;"
		
	print(outputStr, file=fout)
	
# end of OutputRule

def TooManyZeroSlots(seq):
	# Zero-width glyphs are relatively rare (mainly medial jeems), so if there are 
	# a lot of them in the rule, don't bother.
	zeros = 0
	for s in seq:
		if s == 0:
			zeros += 1
			if zeros > 3:
				return True
	return False

def TypicalWidth(w):
	# The numbers below are based on the values used in genKernWidthClasses.py.
	if w == 0:		# zero
		return 50
	elif w == 1:	# narrow
		return 350
	elif w == 2:	# medium
		return 700
	elif w == 3:	# wide
		return 1150
	else:
		return 1500		# extra wide
		
def ClassName(w):
	if w == 0:		# zero
		return "KZero"
	elif w == 1:	# narrow
		return "KNarrow"
	elif w == 2:	# medium
		return "KMedium"
	elif w == 3:	# wide
		return "KWide"
	else:					# extra-wide
		return "KExtra"

# -----------------------------
# Main routine

BariyehWidth = 2700
outfile = "../../source/opentype/bariyehKernRules.feax"
fout = open(outfile, 'w');

print("mode = " + mode)

print("# This file was generated by the genBariyehKernRules.py script.\n", file=fout)

print("lookup Space4BariyehKern {", file=fout)
print("\tlookupflag IgnoreMarks;", file=fout)

# Must match the number of classes generated by the genKernWidthClasses.py script:
numClasses = 5

slotCounts = [1, 2, 3, 4, 5]

for slots in slotCounts:
	stxt = " SLOT" if slots == 1 else " SLOTS"
	print("\n# RULES WITH " + str(slots) + stxt + "\n", file=fout)
	ExpandSeq(mode, [], slots, 0);

print("\n} Space4BariyehKern;", file=fout)

fout.close()

print("Written to '" + outfile + "'")