#!/usr/bin/python3

# Outputs a set of rules to perform bariyeh tail kerning.

# Run this script from the tools/scripts directory where the file is located:
#		python3 genBariyehKernRules.py

# When run in "pos" mode, the output assumes a set of kerning lookups such as:
#		lookup _Kern150 { pos @AllBases 150; } _Kern150;
# etc.
#
# When run in "sub" mode, it assumes a set of lookups such as:
#		lookup _InsSp2Kern150 { sub @Initials by sp150 @Initials } _InsSp2Kern150;
# etc.
#
# This version of the script assumes 6 width classes. We would expect that to be
# better than 5 classes, but it didn't seem to produce any better result, and
# requires many more rules. So currently we are only using 5 classes.

mode = "sub"
#mode = "pos"

import sys

def ExpandSeq(mode, seqSoFar, slotTotal, depth):
	#print("ExpandSeq" + " " + str(slotTotal) + " depth=" + str(depth))
	#print(seqSoFar)
	
	if len(seqSoFar) >= slotTotal:
		needed = OutputRuleIfNeeded(mode, seqSoFar)
		return needed
	else:
		for wc in range(numClasses):
			nextSeq = seqSoFar.copy()
			nextSeq.append(wc)
			#print("nextSeq=")
			#print(nextSeq)
			needed = ExpandSeq(mode, nextSeq, slotTotal, depth+1)
			#print("return to ExpandSeq depth " + str(depth))
			if not needed:
				return True		# nothing more is needed for this sequence, but something might be needed for another
		return True
		
# end of ExpandSeq

def OutputRuleIfNeeded(mode, seq):
	#print("OutputRuleIfNeeded")
	#print(seq)
	totalWidth = 0
	
	if seq[0] == 0:
		return True;	# don't bother with KZeroIni, since the class is empty
		
	if TooManyZeroSlots(seq):
		return True;
		
	for w in seq:
		totalWidth += TypicalWidth(w)
	#print("totalWidth=" + str(totalWidth))
	if totalWidth < BariyehWidth:
		kernValue = BariyehWidth - totalWidth
		OutputRule(mode, seq, kernValue)
		#OutputTextString(seq)
		#print("return True")
		return True
	else:
		#print("return False")
		return False

# end of OutputRuleIfNeeded

def OutputRule(mode, seq, kernValue):
	outputStr = mode + " ";
	first = True
	suffix = "Ini"
	for slot in seq:
		c = ClassName(slot) + suffix
		outputStr += "@" + c
		if first:
			outputStr += "' lookup "
			if mode == "sub":
				outputStr += "_InsSp2Kern"
			else:
				outputStr += "_Kern"
			outputStr += str(kernValue) + "  "
		first = False
		suffix = "Med  "
	outputStr += "nlqBariyehFin;"
		
	print(outputStr, file=fout)
	
# end of OutputRule

def TooManyZeroSlots(seq):
	# Zero-width glyphs are relatively rare (mainly medial jeems), so if there are 
	# a lot of them in the rule, don't bother.
	zeros = 0
	for s in seq:
		if s == 0:
			zeros += 1
			if zeros > 3:
				return True
	return False

def TypicalWidth(w):
	# The numbers below are based on the values used in genKernWidthClasses.py.
	if w == 0:			# zero
		return 0
	elif w == 1:		# narrow
		return 300
	elif w == 2:		# medium
		return 650
	elif w == 3:		# wide
		return 1000
	elif w == 4:		# extra wide
		return 1300
	else:						# huge
		return 1700
		
def ClassName(w):
	if w == 0:		# zero
		return "KZero"
	elif w == 1:	# narrow
		return "KNarrow"
	elif w == 2:	# medium
		return "KMedium"
	elif w == 3:	# wide
		return "KWide"
	elif w == 4:	# extra-wide
		return "KExtra"
	else:					# huge
		return "KHuge"

# -----------------------------
# Main routine

BariyehWidth = 2700
outfile = "../../source/opentype/bariyehKernRules.feax"
fout = open(outfile, 'w');

print("mode = " + mode)

print("# This file was generated by the genBariyehKernRules.py script.\n", file=fout)

# Must match the number of classes generated by the genKernWidthClasses.py script:
numClasses = 6

slotCounts = [1, 2, 3, 4, 5]

for slots in slotCounts:
	stxt = " SLOT" if slots == 1 else " SLOTS"
	print("\n# RULES WITH " + str(slots) + stxt + "\n", file=fout)
	ExpandSeq(mode, [], slots, 0);

fout.close()

print("Written to '" + outfile + "'")