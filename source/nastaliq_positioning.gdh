//
//	File: nastaliq_rules.gdl
//
//	Graphite positioning rules for Awami Nastaliq

/*
	This file is part of the Awami Nastaliq font 
	(http://software.sil.org/awami) and is 
	Copyright (c) 2014-2017 SIL International (http://www.sil.org/),
	with Reserved Font Names "Awami" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including an FAQ.
*/


table(positioning)

pass(1)

//
//	CURSIVE ATTACHMENT
//

#define cursive_attach(P)  c_exit_##P {att {to=@L; with=exit_##P; at=entr_##P}} c_entr_##P {insert=1} / _ MARKS2N ^ _=L ;

// Only used for beh so we don't need to allow upper and lower diacs:
// E.g.,
////	c_exit_behLowTooth {att {to=@L; with=exit_behLowTooth; at=entr_behPreFinalHehGoal}} 
////		c_entr_behPreFinalHehGoal {insert=1} 
////			/ _ MARKS ^ _=L ;

#define cursive_attach2(P1, P2)  c_exit_##P1 {att {to=@L; with=exit_##P1; at=entr_##P2}} c_entr_##P2 {insert=1} / _ MARKS ^ _=L ;


#if (QUICKCOMPILE == 0)


c_exit {att {to=@L; with=exit; at=entrance}} 
	c_entrance {insert=1} 
		/ _ MARKS2N ^ _=L ;

/***
cursive_attach(alef)
cursive_attach(beh)
cursive_attach(behFinal)
cursive_attach(behHighTooth)
cursive_attach(behLowTooth)
cursive_attach2(behLowTooth, behPreFinalHehGoal)
// Special case not handled by macro due to attached-ring:
c_exit_behLowTooth {att {to=@L; with=exit_behLowTooth; at=entr_behPreFinalHehGoal}} 
	c_entr_behPreFinalHehGoal {insert=1} 
	/ _  g__kafTop_null  g__attachedRingMid ^ _=L ;
cursive_attach(behPreReh)
cursive_attach(behPreNoon)
cursive_attach(jeem)
cursive_attach(reh)
cursive_attach(rehHgm)
cursive_attach(rehJkl)
//cursive_attach(rehSshg)
cursive_attach(seen)
cursive_attach(sad)
cursive_attach(tah)
cursive_attach(ain)
cursive_attach(feh)
cursive_attach(meem)
cursive_attach(meemAlt)
cursive_attach(noon)
cursive_attach(hehgoalMedial)
cursive_attach(hehgoalFinal)
cursive_attach(hehdoach)
cursive_attach(chotiyeh)
cursive_attach(chotiyehBfkl)
cursive_attach(bariyeh)
cursive_attach(lamKaf)
cursive_attach(qafWaw)
cursive_attach(qafWawStfh)
***/

//  c_exit_qafWawStfh {  attach {to = @6; with = exit_qafWawStfh; at = entr_qafWawStfh; }  }  c_entr_qafWawStfh { insert = 1;  }  
//              /  _  cNuqtaLikeLower  cNuqtaLikeUpMid  cDiacritic  cDiacritic  ^  _  ;" >


#endif  // QUICKCOMPILE

// EXPERIMENTS
#define SHIFT_N_OUT 0m

// Last resort:
cIniMed {att.to=@L}  cMedFinZJ {insert=1}  / _ MARKS2N ^ _=L ;

// Note that this will not affect the width of visible spaces.

if (wordSpacing == xtight)
g_narrowNoBreakSpace  { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace { advance.x = 75m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == tight)
g_narrowNoBreakSpace  { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == medium)
g_narrowNoBreakSpace  { advance.x = 75m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace { advance.x = 225m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == wide)
g_narrowNoBreakSpace  { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace {advance.x = 300m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == xwide)
g_narrowNoBreakSpace  { advance.x = 225m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace {advance.x = 375m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

(cVisSpace  cshowInv  g_zeroWidthNoBreakSpaceShowInv_alt cShowInvBoxes cEmbedMarkers)
	{ collision.flags = SET_ISSPACE(collision.flags) };

endpass; // 1

endtable;	// positioning


// TEMPORARY
table(glyph)

cIni { zeroS = point(0m, 0m) };
cMed { zeroS = point(0m, 0m) };
cFin { zeroS = point(0m, 0m) };

cNuqtaLike { zeroM = point(0m, 0m); zeroS = point(0m, 0m) };

cDiacritic { zeroM = point(0m, 0m) };

endtable;


//
//  NUQTA POSITIONING
//

table(positioning)

pass(2)

// Use wider spaces for Latin text.
cSpace {advance.x += 200m}  /  _  cLatin;
cSpace {advance.x += 200m}  /  cLatin  _;


// Upper and lower nuqta attachment

table(glyph)

// For some reason I have to subtract something to make these things work. :-/
cn1LowerDia { nByLowerM = point(n1LowerM.x, n1LowerM.y - 1m) };
cn23LowerDia { nByLowerM = point(n23LowerM.x, n23LowerM.y - 1m) };

cTakes_nLowerDia = (cTakes_n1LowerDia cTakes_n23LowerDia);

// For attaching any kind of nuqta-like thing...
cHasUpperMaux = (cNuqtaUpper, gHamzaAbove, g__hamzaArabic, g__smallTah, g__smallTah2dots, g__smallV);
cNuqtaUpper { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };
gHamzaAbove { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__hamzaArabic  { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__smallTah { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallTah2dots { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallV  { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };


// Intersection classes:

cTakes_hamzaAndN23LowerDia = cTakes_n23LowerDia;
cTakes_hamzaAndN23LowerDia &= cTakes_hamzaUpperDia;

cTakes_hamzaAndHehhookDia = cTakes_hamzaUpperDia;
cTakes_hamzaAndHehhookDia &= cTakes_hehhookDia;

cTakes_ringAndNUpperDia = cTakes_nUpperDia;
cTakes_ringAndNUpperDia &= cTakes_ringDia;

endtable;  // glyph


// Special bariyeh rules: move any nuqtas within three chars of a bariyeh down.

// X+NxL  Y+NyL  Z+Nz  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyU  Z+NzL  Bariyeh
// Here we attach the upper nuqta too, since if we back up to attach it, it will reattach and mess up
// the second lower nuqta.
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cMed   cHasUpperMaux   { attach {to = @Y; at = nUpperS; with = nUpperMaux } }
	csMedBy cNuqtaLower       { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  cMed=Y DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Z  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidLeftLowerS; with = nByLowerM } }
	/ _=B1 _=L1 DIACS  _=B2  _=L2  DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y  _=Ny DIACS  ^ gBariyehFin=By;

// X+Nx Y Bariyeh 
cTakes_nLowerDia  cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	/ _=B _=L  DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;



// Not really needed, because all glyphs with lower diacs can take upper diacs
//table(glyph)
//cTakes_n1Lower_and_nUpperDia = cTakes_n1LowerDia;
//cTakes_n1Lower_and_nUpperDia &= (cTakes_nUpperDia);
//endtable;

// kaf-top, nuqta(s) below
/*
cTakes_kafTopDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	ckafTopDia { attach {to = @K; at = kafTopS; with = kafTopM } }
	/ _=K  _=L  _=T;


cTakes_gafStrokeDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
	/ _=K  _=L  _=S;
*/

// tah above, nuqta(s) below
cTakes_tahUpperDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=L  _=U;
// Do we need this? We shouldn't need to attach a tah to a glyph that doesn't take a tah.
//cTakes_n1LowerDia
//	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
//	ctahUpperDia { attach {to = @B; at = nUpperS; with = tahUpperM } }
//	/ _=B  _=L  _=U;

// nuqtas above, hehhook below
cTakes_hehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above and below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// hamza above, nuqtas below
cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
(cBehIni cBehMed)
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;


// Upper nuqta-like attachment


////gJeemFin  cNuqtaLike { attach {to = @J; at = point(574m, 1274m); with = nUpperM} }
////	/  gJeemMedJm=J  cNuqtaLike?  _=J  _=N;

//cTakes_n1hUpperBehSpecialDia
//	cNuqtaLikeUpper { attach {to = @B; at = n1hUpperBehSpecialS; with = nUpperM } }
//	/ _=B  _=U;

// Put hamza rules first to make sure to use hamza APs for them.
cTakes_hamzaAndHehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=H  _=U;

cTakes_hamzaUpperDia
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=U;

cTakes_hamzaLowerDia
	chamzaLowerDia { attach {to = @B; at = hamzaLowerS; with = hamzaLowerM } }
	/ _=B  _=U;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
// TODO: add real hamzaUpper APs to beh forms.
(cBehIni cBehMed)
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=H;

// Bar after kaf needs to be offset vertically.
/*
(cLamMed cLamFin)
	cbarDia { attach {to = @L; at {x = barS.x; y = barS.y + 380m}; with = barM } }
	/ (cKafIni cKafMed)  MARKS  _=L  _=B;
*/

cTakes_barDia
	cbarDia { attach {to = @B; at = barS; with = barM } }
	/ _=B  _=U;

cTakes_squiggleDia
	csquiggleDia { attach {to = @K; at = squiggleS; with = squiggleM } }
	/ _=K  _=S;

cTakes_digitUpperDia
	cdigitUpperDia { attach {to = @B; at = digitUpperS; with = digitUpperM } }
	/ _=B  g__kafTop_null?  _=U;

////cTakes_gafStrokeDia
////	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
////	/ _=K  _=S;

// Use smallV AP if present, otherwise small-V will attach at nUpper - no longer used.
////cTakes_smallVDia
////	g__smallV { attach {to = @B; at = smallVS; with = nUpperM } }
////	/ _=B  _=U;

// lamValt:
cTakes_smallValtDia
	g__smallV { attach {to = @B; at = smallValtS; with = nUpperM } }
	/ _=B {lamValt == 1}  g__kafTop_null?  _=U;

cTakes_nUpperDia
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U;

cTakes_tahUpperDia
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=U;

// nuqtas above, ring below
cTakes_ringAndNUpperDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U _=R;

cTakes_ringDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	/ _=B  g__kafTop_null?  _=R;

// Odd situation, but just in case:
cIso
	gMaddaAbove { attach {to = @B; at = mUpperS; with = mUpperM } }
	/ _=B  _=M;


// Lower nuqta attachment

// Special case: situation below with small nuqtas
(gBehIniBe gBehMedBe gHehGoalIniBe)
	g__dot1l_small { attach {to = @B1; at = n1LowerS; with = n1LowerM } }
	gBehMedJm
	g__dot1l_small { attach {to = @B2; at = n1LowerS; with = n1LowerM } }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin  cNuqtaLikeLower;

// Special case: beh + beh + jeem - don't use special rule below, but do move center nutqa over a bit.
(gBehIniBe gBehMedBe)
	cDot1l { attach {to = @B1; at = nLowerTightS; with = n1LowerM } }
	gBehMedJm
	cDot1l { attach {to = @B2; at = n1LowerS; with = n1LowerM }; shift.x = 100m }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  /*no diac*/  gJeemFin  cNuqtaLikeLower;

// Special case: beh/yeh + beh/yeh + jeem/tcheh - move center nuqta down to the right of the jeem tail.
(gBehIniBe gBehMedBe gHehGoalIniBe)
	cNuqtaLikeLower { attach {to = @B1; at = nLowerTightS; with = n1LowerM } }
	gBehMedJm
	cNuqtaLikeLower { attach {to = @B2; at = nLowerTightS; with = n1LowerM } }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin  cNuqtaLike;

// Special case: lower-nuqta + jeem + beh/yeh + jeem/hah/khah/tcheh - move center nuqta down to the right of the jeem tail.
(gBehIniBe gBehMedBe gHehGoalIniBe gJeemMedBe)
	cNuqtaLikeLower { attach {to = @B1; at = n1LowerS; with = n1LowerM } }
	gBehMedJm
	cNuqtaLikeLower { attach {to = @B2; at = nLowerTightS; with = n1LowerM } }
	/   cNuqtaLikeLower  _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin;

cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_tahLowerDia
	ctahLowerDia { attach {to = @B; at = tahLowerS; with = tahLowerM } }
	/ _=B  _=U;

// Hehhook
cTakes_hehhookDia  g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM } }
	/ _=B  _=H;

// Hehhook - big
////////attachR_BN(	gHehGoalIni,	g__hehHook_big,		default2,		default2_)


// TEMPORARY - fall-back attachment
// Needed to test in Graphite1.
cIniMedFin  g__kafTop_null;

cIniMedFin  cNuqtaLike { attach {to = @1; at = zeroS; with = zeroM } };


// Subtending marks

// NB: at this point digits should be in visual order, right to left,
// so we attach the left-most (logically first) to the sign, and proceed to the right.

cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign4=S;

cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign3=S;

cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign2=S;

cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign1=S;

// However, there is a bug in some implementations (eg Firefox) where the numbers are still in
// logical order.

cSign4=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true};
	
cSign3=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true};
	
cSign2=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true};
	
cSign1=S
	cSignDigit { attach {to=@S;  at=digitS; with=digitM }; insert = true};

endpass;  // 2

endtable;  // pos


#if DO_COL_FIX

// Define fake right and left bounding boundaries that will be compared to the side-bearing marks
// and used to determine the ideal margin/kerning.

table(glyph) {AttributeOverride = 0}

// Define for all needed glyphs where they have not been defined in the font.
cIni {kernBbRightS = point(0m,0m) };
cFin {kernBbLeftS = point(0m,0m) };
cIso {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

cKernPunct = (gComma gFullStop gSemicolon g_colonArab g_exclamArab gQuestionMark g_parenleftArab g_parenrightArab
	g_quoteleftArab g_quoterightArab g_quotedblleftArab g_quotedblrightArab)
		{kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

cQuote = (g_quoteleft g_quoteright g_quoteleftArab g_quoterightArab
	g_quotedblleft g_quotedblright g_quotedblleftArab g_quotedblrightArab);

cQuoteArab = (g_quoteleftArab g_quoterightArab g_quotedblleftArab g_quotedblrightArab);
cQuoteRightArab = (g_quoterightArab g_quotedblrightArab);
cQuoteLeftArab = (g_quoteleftArab g_quotedblleftArab);

endtable;


table(glyph)

cPostKernable = (cIso, cIni, cKernPunct) {
	dbgBbRight = bb.right; dbgRsb = rsb; dbgAdv = advancewidth;
	kernRsb = advancewidth - ((kernBbRightS.x == 0) ? bb.right : kernBbRightS.x);
};

cKernable = (cIso, cFin, cKernPunct) {
	dbgBbLeft = bb.left; dbgLsb = lsb;
	kernLsb = ((kernBbLeftS.x == 0) ? bb.left : kernBbLeftS.x);
}

c_jumpTail = ( cJeemFin, gAinFin );


cls_excludingGlyphs = (cKafMed csKafMed_base) {
	collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

cls_excludingGlyphs_kern = (gKafFin, gGafFin) {
	collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

endtable;  // glyph


// Nuqta collision fixing

table(positioning)

if (collFix > 0)

pass(3)

// Set up for collision fixing

#define MAXKERN 5000m
#define MINKERN -700m
#define MINKERN_TIGHT -3000m
#define MINKERN_WIDE -200m
#define STDMARGIN 150m
#define STDMARGINWT 400
#define STDMARGIN_N1 150m
#define STDMARGINWT_N1 200
#define STDMARGIN_N2 150m
#define STDMARGINWT_N2 200
#define STDMARGIN_DIAC 200m
#define STDMARGINWT_DIAC 400
#define STDMARGIN_DIGIT 250m

#define KERNMARGIN_TIGHT 150m
#define KERNMARGIN_MED 300m
#define KERNMARGIN_WIDE 400m


#define ORDER_UNUQTAS 1
#define ORDER_LNUQTAS 2
#define ORDER_LNUQTAS_SUB_BYEH 3

#define ORDER_UDIACS 4
#define ORDER_LDIACS 5

table(glyph) {AttributeOverride = 1}

cNuqtaLikeUpper {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_UNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 50 };
		valign { height = 275m;	weight = 500 }
	}
};

csNuqta_small { sequence.valign.height = 250m };

gHighHamza { sequence.class = 0 };

cNuqtaLikeLower {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_LNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 500 }; // weight was 50
		valign { height = 275m;	weight = 500 }
	}
};

g__hehHook_small { sequences.class = 0 };

g__bar { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };
g__attachedRing { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };

cgafStrokeDia { collision { margin = 0; flags = 0 }; sequence { class = 0; order = 0 } };


// Smaller nuqta glyphs need larger margins:
cDot1u { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
cDot1l { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
cDot2u { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };
cDot2l { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };


cDiacriticUpper {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; } - set in the rule
};

gNoonGhunnaMark { collision.margin = 300m; marginweight = 300 }; // override

cBase = (cIso, cIni, cMed, cFin, c_zerojoin);

cDiacriticLower {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; } - set in the rule
};

//cNuqtaLikeAbove { collision.order { class = ORDER_UNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };
//cNuqtaLikeBelow { collision.order { class = ORDER_LNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };

endtable; // glyph


// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags); collision.flags = SET_IGNORE(collision.flags) };

c_zerojoin   { collision.flags = SET_IGNORE(collision.flags) };
c_zeronojoin { collision.flags = SET_IGNORE(collision.flags) };
g_zeroWidthNoBreakSpaceShowInv  { collision.flags = SET_IGNORE(collision.flags) };

// Don't move nuqtas to adjust for punctuation; instead kern the punctuation.
cKernPunct { collision.flags = SET_IGNORE(collision.flags) };

g__kafTop_null { collision {flags = COLL_FREEZE} }  /  cBase  _ ;   // make context long enough to give precedence


// Upper nuqtas

// Gaf strokes are considered part of the base - they don't move.
cgafStrokeDia { collision.flags = COLL_FREEZE }  /  cBase  _ ;     // make context long enough to give precedence

// Things on top of alefs should never move horizontally. For now, just don't let them move at all.
// Also, don't force preceding nuqta-like things to move above them.
cNuqtaLikeUpper { collision.flags = COLL_FREEZE; sequence.class = 0 }  /  (gAlef cAlefFin)  _;


// Small V over lam needs to stay nicely centered.
g__smallV { collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 50m;
		min.y = -300m;
		max.y = 300m;
	};
	sequence.class = 0  // eg, \u0646\u0650\u06A9\u06B5
  }  /  (cLamIM cLamFin)  _;

	
// Special case: if there is a nuqta before a zah, scootch the nuqta of the
// zah down pretty close to the base.
/**
cNuqtaLikeUpper { 
	shift { x = 50m; y = -150m }; // note that shifting in RTL moves forward, ie, left.
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 100m;
		min.y = -100m;
		max.y = 300m;
	}
} /  cNuqtaLikeUpper=N1 DIACS  cTahMed  _=N2 ;
**/


// The nuqta on the zah (tah form) fits nicely above it, so it is not normally helpful to move it.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't let this one move left much
	max.x = 100m;
	min.y = -200m;  // shouldn't need to move vertically either, at least by much
	max.y = 300m;
} } / cTahMed _ ;


// Special case: khah + teh/theh + kaf/lam/alef
// Not essential but it does look a little better.
cNuqtaLikeUpper { shift { x=-100m; y = -150m } }  /  gJeemMedBeKl  cNuqtaLikeUpper  cDiacritic?  gBehMed  _=N;

// Special case: hah + teh + alef/lam
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 300m; // don't let it pop up to the top of the alef/lam
} } / (cJeemIM) cNuqtaLikeLower?  cDiacritic?  gBehMed  _ cDiacritic?  (cAlefFin cLamFin cLamMed);
*/

// Exception to special case below when there is a previous lam/kaf.
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / (cLamIM cKafIM) cDiacritic?  cBase  _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);
*/

// Special case involving jeem + noon/teh/sheen - don't allow nuqta to move right
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 100m;  // less than normal
	min.y = -300m;
	max.y = 1000m;
} } / cJeemIM  cNuqtaLike?  cDiacritic?  (cBehMed cSeenMed)  _  ;
*/

// Special case: beh/yeh + kaf/lam + heh-doachashmee - move nuqtas down and to the right
cNuqtaLikeLower {
	shift { x = -250m; y = -300m };
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 350m;
		min.y = -1000m;
		max.y = 300m;
	}
}  /  (gBehIni gBehMed)  _=N  cDiacritic?  (gKafMedHd gGafMedHd gLamMedHd) g__kafTop_null?  cDiacritic?  
			(cHehDoMed cHehDoFin);

// Special cases involving kaf tops - allow nuqtas to move further right than normal.
// Remove for now - this is too extreme.
/***
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 800m; // a lot more than normal
	min.y = -300m;
	max.y = 1000m;
} } / _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);
***/

// Special case: khah + teh/theh + alef/lam - move teh/theh nuqtas above alef/lam - no, we're not doing this
/***
cNuqtaLikeUpper { shift { x = -80m; y = -180m } }
	(cDot2u  cDot3u  gHamzaAbove) { 
		shift { x = 50m; y = 800m; };
		collision {
			flags = SET_FIX(collision.flags);
			min.x = -250m;
			max.x = 200m;
			min.y = -300m;
			max.y = 300m;
		};
		sequence.class = 0;
	}
	/ cJeemIM  _=N1  cDiacritic?  cBehMed  _=N2  cDiacritic?  (gAlefFin  cLamMed  gLamFin);
***/	


// Special case: khah + teh/theh - allow more movement to get the nuqta on the jeem to the right of the nuqta on the beh form.
/*** NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m;  // standard is 200m
	min.y = -300m;
	max.y = 1000m;
} } / cJeemIM _ cDiacritic? cBehMed cNuqtaLikeUpper;
**/

// Special case: beh + jeh + beh; the small-nuqta version is problematic.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = 250m;  // don't let nuqta jump above beh
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } /  cRehFin  _  cDiacritic?  cBehIso;


// Special case: nuqta-small-V + kaf/gaf
g__dot1u_smallVKf {
	shift { x= -130m; y = -230m };
	collision {
		margin = 80m;
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 350m;  // standard is 200m
		min.y = -300m;
		max.y = 1000m;
	};
	sequence.class = 0;
} /  cIni  _  (cKafMed cKafFin);


// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m; // more than normal
	min.y = -300m;
	max.y = 1000m;
} } / cIni cNuqtaLikeLower? _;

// Nuqtas on finals can be moved quite a bit to the left.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;   // more than normal
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } /  cFin _;

/*** Special case: jeem followed by nuqta
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	margin = 250m;
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} }  /  cJeemIni  cNuqtaLike?  cBase  _; 
***/

// Default case: nuqtas above (other than initial) can move more to the left than the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} };


// Middle nuqta-like stuff: bars and rings
// Ideally it would be nice to be able to move the bars up and down a little to avoid
// collisions, but to do that we would need to be able to ignore the base (lam) from
// the perspective of the bar.

g__bar { collision.flags = COLL_FREEZE }    /  cBase  _ ;  // add context to increase precedence
g__attachedRing { collision.flags = COLL_FREEZE }  /  cBase  _ ;

// Lower nuqtas

// Nuqtas before certain finals can move down quite a bit to jump below swashes.
// Note that if we make the lower limit too low, the nuqtas will jump completely *below* 
// the swash, which is not what we want. We want it to be down and to the right.
cNuqtaLikeLower_jump {
	//shift.y = -800m; // do we want this?
	//shift.x = 200m; // since we are not using the sequence attrs, avoid it moving down and to the left of another nuqta
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 700m;	// a lot!
		min.y = -1600m; // a lot!
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / _  c_jumpTail;

// Gueh vertical dots must stay close to the kaf stem.
cDot2vl {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 150m;
		min.y = -1000m;
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / cKafIM  g__kafTop_null  _=N;


// Nuqtas below a bariyeh cannot move up, shouldn't need to move down, and they don't flow diagonally.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -400m;
		max.x = 400m;
		min.y = -20m;
		max.y = 0m;
  };
  sequence { class = 0; order = 0 }
} / cIni?  _ {underBy == true};


// Heh-hooks need to be kept centered under the base. But because they are originally positioned quite a bit to the left
// they can move right a lot. 400 lets it move to the right side of the heh-goal, and avoid a following jeem.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 400m;
	min.y = -1000m;
	max.y = 50m;
} }  /  cIniMed  _; // enough context to give it precedence

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 400m;  // 600 breaks \u067E\u0650\u06CC\u064F\u0648
	min.y = -1000m;
	max.y = 300m;
} }  /  cIni  _;

// Default case: nuqtas below (other than initial) can move more to the right than the left.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 350m;   // making this 400 helps \u067E\u0650\u06CC\u0686\u06BE\u06D2 but breaks other things
	min.y = -1000m;
	max.y = 300m;
} };

// Exclusion glyphs for space above kafs and gafs

// For ngoeh or kaf w/ 3 dots, don't using the exclusion glyph - 
// the nuqtas need to go right on top of the gaf.
//(cls_excludingGlyphs cls_excludingGlyphs_kern)
cKafNoIso
		{ collision {
			flags = CLEAR_FIX(collision.flags);
			flags = CLEAR_KERN(collision.flags);
		} } 
	(cDot2u cDot3u) { shift { x = 200m; y = -100m } }
	/ _  g__kafTop_null? _;


// There is a bug in the Graphite engine that mis-initializes the exclusion glyph that causes bugs in the
// collision fixing.
// For now, until this gets fixed, just set the exclusion glyph if a neighboring glyph has an upper nuqta.
// Eventually, remove the context for the next two rules and merge them.
cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  _=EG;

cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  _=EG  g__kafTop_null?  cDiacritic?  cBase  cNuqtaLower? cNuqtaUpper;

cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  _=EG;

// Special case: teh/theh + jeem + kaf
// Include the exclusion glyph for this case as well, to avoid nuqtas on the jeem jumping up.
cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  cJeemMed  MARKS  _=EG;


// Don't kern glyphs before the high hamza; retain the space.
// Move kerning special cases down to pass 10.
////cKernable  (gHighHamza gHighHamzaArabic);

// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
// We actually set the kerning parameters in the final pass. But here, at least indicate
// which glyphs can be kerned, which affects how shifting works around them.

cKernable { collision {
	//---flags = SET_FIX(collision.flags); -- move actual kerning to end of process
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	////max.x = 300m; min.x = 0;  // kerning right is logically equivalent to shifting left in RTL
	//---max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


// Other bases are not moved.
cIniMed { collision { flags = COLL_FREEZE } };

cDiacritic { collision.flags = SET_IGNORE(collision.flags) };	// these have not been attached, so don't bother with them

cQuoteArab { collision.flags = SET_IGNORE(collision.flags) }; // fix with kerning

endpass; // 3

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.
if (collFix > 1)
pass(4) { CollisionFix = 5 }
// Perform base + nuqta collision fixing. Any failures leave for now.
endpass;
endif;

/**************************************

#define CHARSEQ cMed cNuqtaLike? cDiacritic?
#define SEQ2 [[CHARSEQ]? CHARSEQ]?
#define SEQ3 [[[CHARSEQ]? CHARSEQ]? CHARSEQ]?
#define YBELOWBYEH -450

if (collFix > 1)
pass(4) { CollisionFix = 4 }

// Next: adjust for nuqtas moved below a bariyeh.
// Needed for, eg, \u0686\u067E\u0679\u06CC\u0646\u06D2

cNuqtaLikeLower {
	collision.max.y = 0m; // ideally this would be set to what it is shifted by already
	sequence { class = ORDER_LNUQTAS_SUB_BYEH; order = 0 }
}  / (c_medial c_initial)  _ {position.y < 0}  cDiacritic?  SEQ2 gBariyehFin;

// Nuqtas still above a bariyeh need more flexibility; if they are initial, let them move right:
cNuqtaLikeLower {
	collision.max.x = 750m;
	sequence.class = 0;
}  / cIni  _ {position.y > 100m}  cDiacritic?  SEQ2 gBariyehFin;


endpass;  // 4
endif;    // collFix > 1

*****************************************/

endtable;

#endif // DO_COL_FIX

/*****  Not needed - the collision-fix pass sets all the positions accurately.
table(glyph)
cNonBaseTemp = (cNuqtaLike  g__kafTop_null)
endtable;

#define NOTSET 12345  // some number that is not likely to be a real value

c_initial {user6 = position.y}  c_final {user6 = position.y}   / _=I  MARKS2N  _=F;
c_initial {user6 = position.y}  c_medial {user6 = position.y}  c_final {user6 = position.y} / _=I MARKS2N  _=M MARKS2N _=F;

c_medial {user6 = NOTSET}  c_medial {user6 = position.y}   c_final {user6 = NOTSET}
	/ ^ cIniMed cNonBaseTemp?  _=M1  cNonBaseTemp?  _=M2 cNonBaseTemp?  _=F {user6==0};

c_medial {user6 = NOTSET}  c_medial {user6 = position.y}
	/ ^ cIniMed MARKS2N  _=M1 MARKS2N  _=M2 {user6 == NOTSET};

c_initial {user6 = position.y}  c_medial {user6 = position.y}  /  _=I  MARKS2N  _=M {user6==NOTSET} ;

// Do this last:
c_final {user6 = position.y}  /  _ {user6 == NOTSET};
*****/


#define pairKern user2
#define tooHigh user3

// currently not used
////#define marginSet user4  -- currently not used


table(positioning)

//
//	KAF HEIGHT ADJUSTMENTS
//

table(glyph)

cNuqtaLikeUpperNoKT = (cNuqtaLikeUpper);
cNuqtaLikeUpperNoKT -= (g__kafTop_null);

c_narrow = (gBehMed gMeemMed gAinMed);

endtable;

// Since the last positioning pass does not block the area above the kaf, limit the movement
// of nuqta behind/under a kaf.
#define STAYBELOWKAF {collision {min.x = 0m; max.y = 300m}}

pass(5)

// Kaf-top collision fixing/prevention and tall sequences

// Special case: alef-madda + kaf/gaf + final-heh-goal/beh/tah/feh - make kaf tall so alef-madda can squeeze in
csKafIni_medium  g__kafTop_null
	>  csKafIni_base$K  csKafIni_top_taller$K
	/  gAlefMaddaAbove  _=K  _=T  MARKS (gHehGoalFin gBehFin_bfkl gTahFin gFehFin cDalFin);


// Tall: large-nuqta + kaf 
cNuqtaUpperLarge  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N  cDiacritic?  _=K  _=T;

// Tall: lam/tah + kaf
// TODO: move cBaseTall back into context
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B1  csKafMed_base$K  csKafMed_top_tall$K
	/  _=B1  MARKS  _=K  _=T;

// Tall: short-lam + kaf + ring (short-lams are ALMOST short enough to fit under kaf-rings, but not quite)
(gLamIni_short gLamMed_short)  csKafMed_medium  g__kafTop_null
	>  @L  csKafMed_base$K  csKafMed_top_tall$K
	/  _=L  MARKS  _=K  _=T  g__attachedRingMid;

// Tall: tall kaf + kaf/gaf (note: does not apply to gaf + kaf)
csKafMed_medium  g__kafTop_null
	>  csKafMed_base$K2  csKafMed_top_tall$K2
	/  csKafIM_base g__kafMedTop_tall  MARKS  _=K2  _=T2;

cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF csKafMed_base$K  csKafMed_top_tall$K
	/  _=N cBaseTall  MARKS  _=K  _=T;

// Tall: nuqta + diac + kaf
cNuqtaLike  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N  cDiacriticUpper  cDiacriticUpper?  _=K  _=T;

// Tall: nuqta+smallV + kaf
(g__dot1u_smallVKf g__dot1u_smallV)  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N  cDiacriticUpper?  _=K  _=T;

// Tall: alef + diac + kaf
cDiacriticUpper  csKafIni_medium  g__kafTop_null  
	>  @D STAYBELOWKAF  csKafIni_base$K  csKafMed_top_tall$K
	/  (gAlef cAlefFin)  _=D  _=K  _=T;

// Special case: exception to rule below when form before kaf is a jeem (eg, \u0641\u062E\u06AF\u0633):
cDot1u  cDot1u  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N1  cDiacritic?  cJeemMed  _=N2  cDiacritic? ^ _=K  _=T;

// Don't change: single-nuqta + single-nuqta + kaf (eg, \u0628\u0650\u0646\u0650\u0646\u06AF\u064E\u06A9\u06C1)
cDot1u  cDot1u  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  @K  @T
	/  _=N1  cDiacritic?  cMed  _=N2  cDiacritic? ^ _=K  _=T;

// Tall: nuqta + nuqta + kaf (eg, sheen + teh + kaf)
cNuqtaLikeUpperNoKT  cNuqtaLikeUpper  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N1  cDiacritic?  cMed  _=N2  cDiacritic?  _=K  _=T;

// nuqta + diac + kaf => default
csKafMed_medium  g__kafTop_null  >  @K  @T
	/  cNuqtaUpperSmall  cDiacritic  _=K  _=T;

// Short + medium-short: gaf + ??? + kaf/gaf
csGafIM_medium g__kafTop_null  cNuqtaLikeUpper  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  
			@Nfb STAYBELOWKAF // keep nuqta from hopping above kaf
			csKafMed_base$K  csKafMed_top_medshort$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) _=Nfb cDiacritic? _=K _=Tk;

csGafIM_medium g__kafTop_null  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) cNuqtaLike? cDiacritic? _=K _=Tk;


// Gaf + kaf/gaf-medial => shorter
csGafIM_medium  g__kafTop_null  csKafMed_medium  g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_base$K  csKafMed_top_tall$K
	/  _=G _=Tg  cNuqtaLike?  cDiacritic?  _=K _=Tk;

// Gaf + kaf/gaf-final => short
csGafIM_medium  g__kafTop_null  (gKafFin gGafFin)
	>  csGafIM_base$G  csGafIM_top_short$G  @K
	/  _=G _=Tg  cNuqtaLike? cDiacritic? _=K;

// Medium-short: lam/tah + jeem + kaf
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=B  cNuqtaLike? cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Medium-short: tah + beh/meem/ain + kaf...
cTahIM  csKafMed_medium  g__kafTop_null  
	>  @Ta  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=Ta cNuqtaLike? cDiacritic?  c_narrow cNuqtaLike? cDiacritic?  _=K  _=T;

// Medium-short: nuqta + jeem + kaf...
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N {shift.x = -300m; collision {max.x = 600m; max.y = 200m}} // move right, not up
			csKafMed_base$K  csKafMed_top_medshort$K
	/  _=N  cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Short round form: tah + kaf + lam/alef
cTahIM  csKafRound_medium  g__kafTop_null
	>  @Ta  csKafRound_short  @Null
	/  _=Ta MARKS  _=K MARKS  _=Null;

// No change (\u062C\u0646\u06AF\u06CC)
cDot1u  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  @K  @T
	/  cJeemIM  cNuqtaLike?  cDiacritic?  cMed  _=N  cDiacritic?  _=K  _=T;

// Tall (\u062E\u064F\u0634\u06A9\u06CC)
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  cJeemIM  cNuqtaLike?  cDiacritic?  cMed  _=N  cDiacritic?  _=K  _=T;

// height at which to invoke various short forms
#define SHORTERKAF_HT	1900m
#define SHORTKAF_HT  	1300m
#define PUSHDOWN		3280m
#define PUSHUP			-630m
#define SHORTFINAL2		2300m
#define SHORTFINAL1		2900m
#define	SHORTFINAL0		3100m
#define SHORTFINAL_KAF	1600m

// Situations where short kaf is needed due to height (except cases above where we know it's not appropriate)

cNuqtaLikeUpper?  cDiacritic?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @D  csKafIM_base$K  csKafIM_top_shorter$K
	/  _=N  _=D  _=K {position.y > SHORTERKAF_HT && (shortForms == 1 || shortForms == 3)}  _=T;


cNuqtaLikeUpper?  cDiacritic?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @D  csKafIM_base$K {user5 = bb.top; user6 = position.y + bb.top}  csKafIM_top_short$K
	/  _=N  _=D  _=K {position.y > SHORTKAF_HT && (shortForms == 1 || shortForms == 3)}  _=T;


// Like rule below, but don't move ngoeh nuqtas down so far, because (a) they are already pushed down a bit,
// (b) they don't always get collision-fixed, and (c) the diagonal stroke of the gaf sticks up anyway.
cNuqtaLikeUpper { shift.y -= 100m; collision.margin -= 50m } / cKafNoIso cKafTop  _ { position.y > PUSHDOWN };
// If a nuqta is up above the line, move it down and let the collision fixing algorithm pop it
// back up if necessary.
cNuqtaLikeUpper { shift.y = -200m  /* ; collision.margin -= 50m */ } / _ { position.y > PUSHDOWN };
// Similarly for tall nuqtas below the line, if they also have a diacritic under them.
cNuqtaLikeLowerTall { shift.y = 100m; collision.flags = CLEAR_FIX(collision.flags) }
	/ _ { position.y < PUSHUP } cNuqtaLikeUpper? cDiacriticLower;


// If a nuqta is not near a height-adjusted kaf, turn off collision fixing for next time around.
// Note that this also turns it off for g__kafTop_null, which is fine (although it should already be off).
cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };

// Debugging:
//////cIni {user5 = bb.top; user6 = position.y + bb.top};

endpass;  // pass 5


table(glyph)
csFinal_regular = (gSeenFin, gChotiyehFin, gChotiyehFin_bfkl, gNoonFin,
	gQafFin, gQafFin_stfh, gLamFin, gMeemFin);
csFinal_short = (gSeenFin_short, gChotiyehFin_short, gChotiyehFin_bfkl_short, gNoonFin_short, 
	gQafFin_short,gQafFin_stfh_short, gLamFin_short, gMeemFin_short);
endtable;

if (shortForms > 1)
pass(6)

// high initial with both nuqta and diacritic:
cIni     cMed  >  @I  @M {tooHigh = 1}    /  _=I  {position.y + bb.top > SHORTFINAL2}  cNuqtaLikeUpper  cDiacriticUpper ^ _=M;
// high initial with nuqta OR diacritic
cIni     cMed  >  @I  @M {tooHigh = 1}   
	/  _=I  {position.y + bb.top > SHORTFINAL1}  cNuqtaLikeLower? (cNuqtaLikeUpper  cDiacriticUpper) cDiacriticLower? ^ _=M;
// high initial with no nuqta or diacritic
cIni     cMed  >  @I  @M {tooHigh = 1}    /  _=I  {position.y + bb.top > SHORTFINAL0}  MARKS ^ _=M;

csKafIM_medium  cMed  >  @I  @M {tooHigh = 1}  /  _=I  {tooHigh == 1 || position.y > SHORTFINAL_KAF}  MARKS ^ _=M;
csKafIM_base    cMed  >  @I  @M {tooHigh = 1}  /  _=I  {tooHigh == 1 || position.y > SHORTFINAL_KAF + 100m}  MARKS ^ _=M;

cMed      cMed  >  @M1 @M2 {tooHigh = 1}   /  _=M1 {tooHigh == 1}  MARKS ^ _=M2;

cMed  csFinal_regular  >  @M  csFinal_short    /  _=M  {tooHigh == 1}  MARKS  _=F;

endpass;  // 6
endif;


pass(7)

// Due to an infelicity in the Graphite engine, we can't substitute and attach in the same rule,
// so we have to do it in a separate pass.

table(glyph)
ckafTop_bjDia { kafTopM = point(kafTop_bjM.x, kafTop_bjM.y) }; // to avoid warnings; will never be used
endtable;

// ngoeh nuqtas
cTakes_kafTop_bjDia=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true}
	cNuqtaUpper { shift.y += @T.ktDelta;  collision.flags = SET_FIX(collision.flags) };
cTakes_kafTopDia=B     cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM};    passKeySlot = true}
	cNuqtaUpper { shift.y += @T.ktDelta;  collision.flags = SET_FIX(collision.flags) };

// rings
cTakes_kafTop_bjDia=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };
cTakes_kafTopDia=B     cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };

cTakes_kafTop_bjDia=B  ckafTop_bjDia {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true};
cTakes_kafTopDia=B     cKaf_top      {att {to=@B; at=kafTopS;    with=kafTopM};    passKeySlot = true};


c_exit_chotiyeh {att {to=@F; with=exit; at=entrance}}
	gChotiyehFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_chotiyehBfkl {att {to=@F; with=exit; at=entrance}}
	gChotiyehFin_bfkl_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;

table(glyph)
// Use a slightly higher AP when attaching to a short bariyeh, to save a little more space:
c_exit_bariyeh { exit_by_alt.x = exit.x + 12m; exit_by_alt.y = exit.y + 30m };
endtable;

////c_exit_bariyeh {att {to=@F; with=exit_by_alt; at=entr_bariyeh}}	gBariyehFin_short {passKeySlot = true; insert = 1}
////	/  _ MARKS2N ^ _=F;

c_exit_seen      {att {to=@F; with=exit;  at=entrance}}  gSeenFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_noon      {att {to=@F; with=exit;  at=entrance}}  gNoonFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_qafWaw    {att {to=@F; with=exit;  at=entrance}}  gQafFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_qafWawStfh {att{to=@F; with=exit;  at=entrance}}  gQafFin_stfh_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_lamKaf     {att {to=@F; with=exit; at=entrance}}  gLamFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_meem       {att {to=@F; with=exit; at=entrance}}  gMeemFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;



table(glyph) {AttributeOverride = 0}

// to avoid warnings; will never be used
g__kafTop_null { nUpperS = point(0m,0m) };
csFinal_short { hamzaUpperS = point(0m,0m); tahUpperS = point(0m,0m); n1LowerS = point(0m,0m); n23LowerS = point(0m,0m) };
cNuqtaLikeUpper { nUpperM = point(0m,0m) };
cNuqtaLikeLower { n1LowerM = point(0m,0m) };
cIsoFin { n1LowerM = point(0m,0m); mUpperS = point(0m,0m) };
cKafTop { mUpperS = point(nUpperS.x,nUpperS.y); n1LowerS = point(0m, 0m) };
// Temporary:
g__kafIniTop_medshort { n1LowerS = point(0m, 0m) };
g__gafIniTop_medshort { n1LowerS = point(0m, 0m) };

// Intersection class:
cTakes_smallV_short = csFinal_short;
cTakes_smallV_short &= cTakes_smallValtDia;

cTakes_ring_short = csFinal_short;
cTakes_ring_short &= cTakes_ringDia;

endtable;  // glyph

csFinal_short  chamzaUpperDia {att {to=@F; at=hamzaUpperS; with=hamzaUpperM}} / _=F  _;
csFinal_short  ctahUpperDia   {att {to=@F; at=tahUpperS; with=tahUpperM}}     / _=F  _;
csFinal_short
	cn23LowerDia {att {to=@F; at=n23LowerS; with=n23LowerM}; collision.flags = SET_FIX(collision.flags)}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
cTakes_ring_short
	g__attachedRing {att {to=@F; at=ringS; with=ringM}}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
csFinal_short
	cNuqtaLikeLower {att {to=@F; at=n1LowerS; with=n1LowerM}}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
cTakes_smallV_short cNuqtaLikeUpper {att {to=@F; at=smallValtS; with=nUpperM}}  / _=F {lamValt == 1} _;
csFinal_short       cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}     / _=F  _;
cTakes_ring_short	g__attachedRing {att {to=@F; at=ringS; with=ringM}}	  	   / _=F  _;
endpass;


//
//	DIACRITIC ATTACHMENT
//


// Order of glyphs: base, nuqta below, nuqta above, diacritics below, diacritics above
// But if an upper diacritic is in a "closer" mark class (eg, cMark1), it can come before the lower diacritic.

#if DO_COL_FIX
pass(8)
#else
pass(4)
#endif // DO_COL_FIX


// Attach diacritics
 
table(glyph) { AttributeOverride = false }

// Classes of nuqtas and things that attach closely like nuqtas.
// These are basically defined for the purpose of ignoring in the context of attaching
// diacritics to things.
c_attLikeNqUpper = (cNuqtaLikeUpper); // includes small tah
c_attLikeNqLower = (cNuqtaLikeLower, g__hehHook_small);
c_attLikeNqLowMid = (c_attLikeNqLower, cNuqtaLikeMiddle,
	g__kafTop_null); // diacs don't attach to this, so attach to the base even if this is there
c_attLikeNqUpMid = (c_attLikeNqUpper, cNuqtaLikeMiddle);

// To avoid warnings in special-case attachment rules:
gTahFin { n1LowerS = point(mLowerS.x, mLowerS.y) };
gTehMarbutaFin  { n1LowerS = point(mLowerS.x, mLowerS.y) };

endtable;  // glyph


/****
// Alternate approach to honorifics with diacritics - attach them to the diacritic:
table(glyph)
gZabar { honorificS = point(-200m, 300m) };
gPesh { honorificS = point(-200m, 300m) };
endtable;

cDiacriticUpper=D  chonorificDia=H {att {to=@D; at=honorificS; with=honorificM}; insert=true}
		/ ^ _  _ {att.to==0};
****/

// Special case: beh/peh + upper diacs + honorific - move honorific further off to the left
// (it normally goes where upper diacs go).
(cBehFin gBeh)=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true; shift {x = 800m; y=400m} }
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// diacritic AND honorific attached to final base or its nuqta;
// honorific is positioned off to the left
cIsoFin=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

cIsoFin=B  
	cDiacriticUpper=D {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// honorific attached to final beh with lower nuqtas, w/o upper diac - 
// uses standard upper nuqta location raised a little higher
cBehFin=B  chonorificDia=H {att {to=@B; at {x=nUpperS.x; y=nUpperS.y + 300m}; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};


// Nuqta + upper and lower diacritic
// Eg, noon-nuqta + noon-ghunna-mark + zair (\u0646\u0658\u0650)
cTakes_nUpperDia=B  cNuqtaUpper=N
	cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}}
	cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}}; 


// attach to nuqta
cTakes_mUpperDia  c_attLikeNqUpper=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower? _=D {att.to==0};
cTakes_mLowerDia  c_attLikeNqLower=N  cDiacriticLower {att {to=@N; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  _=N  c_attLikeNqUpMid?  _=D {att.to==0};


// Special contextual cases - eg, kaf/lam followed by tailed final 
cTakes_mLowerCDia=B  cDiacriticLower {att {to=@B; at=mLowerCS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0}  (gAinFin gChotiyehFin gChotiyehFin_bfkl gJeemFin);

// Only a few glyphs attach the small alef at a special place.
cTakes_alefDia=B  gKharizabar {att {to=@B; at=alefS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Diacritics attach to tah above the stem, not where the nuqta goes:
cTakes_mTahUpperDia=B  cDiacriticUpper {att {to=@B; at=mTahUpperS; with=mUpperM}; insert=true}
		/  ^ _=B  c_attLikeNqUpper?  cDiacriticLower?  _=D {att.to==0};

// Attaching to final form, or nuqta, uses mUpper/LowerS.
cTakes_mUpperDia=B  cDiacriticUpper {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_mLowerDia=B  cDiacriticLower {att {to=@B; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Taller or shorter kafs - attach to top, not base
cTakes_nUpperDia  cKafTopAltHt  cDiacriticUpper {att {to=@T; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  _=T  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};

// Attaching standing-alef to lam
(gLamFin cLamIM)=L  gKharizabar {att {to=@L; at=nUpperS; with=mUpperLamM}; insert=true};
gLam=L  gKharizabar {att {to=@L; at=mUpperS; with=mUpperLamM}; insert=true};

// Attaching to initial/medial base - uses stationary nuqta APs.
cTakes_nUpperDia=B  cDiacriticUpper {att {to=@B; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  g__kafTop_null?  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_n1LowerDia=B  cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}; insert=true}
		/ ^ _=B  cKafTop?  c_attLikeNqUpMid?  _=D {att.to==0};

// attach to diacritic
cDiacriticUpper=D1  cDiacriticUpper {att {to=@D1; at=mUpperS; with=mUpperM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};
cDiacriticLower=D1  cDiacriticLower {att {to=@D1; at=mLowerS; with=mLowerM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};

// Not needed because we have a nuqta+smalltah glyph:
////c_attLikeNqUpper=N  g__smallTah=T {att {to=@N; at=mUpperS; with=mUpperM} };

// Hamzas that act like diacritics (but don't reattach them if they're already attached):
cTakes_hamzaUpperDia   cHamzaAbove  /  _ ^ _; // already attached
cTakes_hamzaLowerDia   cHamzaAbove  /  _ ^ _;
cTakes_mTahUpperDia=B  cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mTahUpperS; with=hamzaUpperM} } /  _ ^ _ ;  // tah
cTakes_mUpperDia=B     cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mUpperS; with=hamzaUpperM} } /  _ ^ _ ;
cTakes_nUpperDia=B     cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=nUpperS; with=hamzaUpperM} } /  _ ^ _ ;
cTakes_mLowerDia=B     cHamzaBelow {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mLowerS; with=hamzaLowerM} } /  _ ^ _ ;
cTakes_n1LowerDia=B    cHamzaBelow {collision.flags = SET_FIX(collision.flags); att {to=@B; at=n1LowerS;with=hamzaLowerM} } /  _ ^ _ ;


endpass; // pos - 8 (or 4)


// Kerning pair adjustments

table(glyph) { AttributeOverride = 1 }

// alef, dal, reh, reh-sshg, reh-jkl, reh-???, waw, heh-goal, noon

cKernable { kernPreAlef = 0m; kernPreDal = 0m; kernPreReh = 0m; kernPreWaw = 0m;
	kernPreLamAlef = 0m; kernPreKafNoSp = 0m; kernPreShort = 0m;      // kernPreInitial = 0m;
	kernPreExclam = 0m;
	minKernDelta = 0m };

cDalIso		{ kernPreAlef = -60m };
gDalFin		{ kernPreAlef = -90m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m };
cRehIso		{ kernPreAlef = -90m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m;
				// Before a two-letter sequence:
				kernPreShort = 80m };
gRehFin_jkl	{ kernPreAlef = -70m };
gWaw		{ kernPreAlef = -80m; kernPreReh = 40m };

gRehFin		{ minKernDelta = -400m };
gRehFin_jkl	{ minKernDelta = -400m };
//gRehFin_sshg { minKernDelta = -400m }; -- obsolete
gRehFin_hgM { minKernDelta = -400m };

// Don't let punctuation kern underneath following segment:
cKernPunct { minKernDelta = MINKERN * -1 };

// To account for the fact that the top edge of the kaf pushes the top of the alef away:
///gAlef { kernPreKafNoSp = -150m };
///gAlefFin { kernPreKafNoSp = -80m };

// Digits

cDigitArabic  { kernPreZero = 0m; kernPreOne = 0m; kernPostOne = 0m };
cDigitEastern { kernPreZero = 0m; kernPreOne = 0m; kernPostOne = 0m };

gEasternSeven { kernPreZero = 125m };

gOne { kernPreOne = 50m };
gEasternOne { kernPreOne = 50m };
gNine { kernPreOne = 50m };
gEasternNine { kernPreOne = 50m };
gSix { kernPreOne = 50m };
gEasternSix { kernPreOne = 50m };

gTwo { kernPostOne = 50m };
gEasternTwo { kernPostOne = 50m };
gThree { kernPostOne = 50m };
gEasternThree { kernPostOne = 50m };

// Finals with little tails:
gTah { kernPreExclam = -200m };
cTahFin { kernPreExclam = -200m };
gHehDo { kernPreExclam = -250m };
cHehDoFin { kernPreExclam = -250m };
gWaw { kernPreExclam = -150m };
cWawFin { kernPreExclam = -150m };


endtable; // glyph


pass(9)

// Special cases involving nuqtas.

table(glyph)
cNlWide = (cDot2l  cDot3l  cDot4l);
cDRW_IF = (cDalIso cDalFin cRehIso gRehFin_jkl cWawIso cWawFin);
cRehFin_longtail = (gRehFin, gRehFin_hgM);
endtable;

// Special case: \u0631\u06CC\u0631, \u0634\u0632\u062F\u06CC\u0648
cDRW_IF  (gBehIniRe gBehIniQf)  cNuqtaLikeLower {shift {x = 170m; y = -400m}}  (gRehFin_jkl cWawFin)
	/  _=DR cDiacritic? _=B _=N cDiacritic?  _=RW;

// Special case: \u063A\u0632\u06CC\u0631; see also pass below where the margin for the reh is adjusted
cRehFin_longtail {collision.margin=30m}  (gBehIniRe gBehIniQf)  cNuqtaLikeLower {shift {x = -80m; y = 150m}}  (gRehFin_jkl cWawFin)
	/  _=R cNuqtaLike? cDiacritic?  _=B _=N cDiacritic?  _=RW;

// Special case: \u0627\u06CC\u0645\u0627
gAlef  gBehIniMmX  cNlWide {shift {x = 300m; y = -650m}}  gMeemMed_alt;

// Special case: \u06af\u064f\u06af
// Move diacritic to the right; there is no good place for it.
csKafIM_base  cKafTop  cDiacriticUpper {shift {x = -800m; y = 100m}} cKafNoIso;

// Special case: \u06a9\u0648\u062a\u0645\u06c1\u0627 - NOT NEEDED?
//gWawFin { pairKern = 80m }
//	/  _  gBehIniMm  cNuqtaLikeUpper?  gMeemMedHgM  gHehGoalMed  g__hehHook_small  cAlefFin;

// Special case: reh + Arabic hamza
(gReh gZain gHehGoalFin) { pairKern = 50m }  /  _  gArabicHamza;

// Low priority special case:
////gRehFin {collision.margin = 50m; marginSet = 1}  gBehIniFe  cNlWide; /// {shift {x = 150m; y = 70m}; collision.margin = 50m};

// Special case: closing paren + quote
// TURN ON FOR BUG:
g_parenleftArab { pairKern = -200m }  /  _  cQuoteLeftArab;
// The auto-kerning mechanism didn't want to fix this for some reason. Just do standard kerning.
// TURN OFF FOR BUG:
////cQuoteLeftArab { kern.x = -100m }
////	/  g_parenleftArab  _;



// Set up kerning pairs.

cKernable { pairKern = kernPreAlef }	/  _ ^ MARKS  cKernIgnore?  (cAlefIso);
cKernable { pairKern = kernPreDal  }	/  _ ^ MARKS  cKernIgnore?  (cDalIso);
cKernable { pairKern = kernPreReh  }	/  _ ^ MARKS  cKernIgnore?  (cRehIso);
cKernable { pairKern = kernPreWaw  }	/  _ ^ MARKS  cKernIgnore?  (cWawIso);
cKernable { pairKern = kernPreLamAlef}	/  _ ^ MARKS  cKernIgnore?  gLamIniAl;  // gLafAlef - no longer used
cKernable { pairKern = kernPreExclam }	/  _ ^ MARKS  cKernIgnore?  g_exclamArab;

// Currently not being used:
////cKernable { pairKern = kernPreKafNoSp + @K.position.y }   /  _ ^ MARKS  (gKaf  gGaf  cKafIni)=K;

gAlefMaddaAbove { pairKern = -150m }  /  _ ^ MARKS  cKernIgnore?  (cKafIni csKafIni_base cKafIso)
	[MARKS  ANY]?;  // superfluous slots to increase precedence over two-letter sequence rule below

// Before a two-letter sequence:
cKernable { pairKern = kernPreShort }  /  _ ^ MARKS  cKernIgnore?  cIni MARKS  cFin;


// Notice that with digits, which are LTR, we put the kern value on the opposite glyph, ie, the FOLLOWING
// glyph which will be right-most when rendered.
( gEasternZero  gZero ) { pairKern = @D.kernPreZero }   /  _  (cDigitEastern cDigitArabic)=D;
( gEasternOne  gOne )   { pairKern = @D.kernPreOne }    /  _  (cDigitEastern cDigitArabic)=D;
(cDigitEastern cDigitArabic) { pairKern = kernPostOne } /  _  ( gEasternOne  gOne );


// Bogus rule that will never fire (for if we disable this pass for debugging):
///////////////gRrehFin_jkl cDiacritic cDiacritic cDiacritic { user4 = 10 };


// Diacritics that extend above/below the line

cNuqtaLike?  cDiacriticUpper  /  (cKafIM csKafIM_base)  cKafTop  _  _;  // ... but not on kafs or gafs

// For tahs, the diac is not attached to the nuqta, so don't move the nuqta down.
cTahIM  cNuqtaUpper  cDiacriticUpper  { shift.y -= 200m; collision.margin -= 20m }
	/  _=T  _=N  _=D { position.y > 2800m };
cNuqtaUpper { shift.y -= 150m  }
	cDiacriticUpper { shift.y -= 300m; collision.margin -= 20m }  /  _=N  _=D { position.y > 2800m };
cDiacriticUpper { shift.y -= 100m; collision.margin -= 150m } /  cKafIM  cNuqtaLikeUpper?  _ { position.y > 2800m };
cDiacriticUpper { shift.y -= 300m; collision.margin -= 70m }  /  _ { position.y > 2800m };
// -1350 permits a single diacritic under a standard bowl to remain at the standard position
cDiacriticLower { shift.y += 150m; collision.margin -= 70m }  /  _ { position.y < -1350m }; // was -1200


endpass;  // 9


#if DO_COL_FIX

// Diacritic collision fixing and kerning

if (collFix > 0)

pass(10) // { CollisionFix = 4; AutoKern = true }


// Set up diacritic collision fixes and kerning.

// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags) };  /// collision.flags = SET_IGNORE(collision.flags) };

// Kaf exclusion glyphs don't affect diacritics.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision.exclude.glyph = 0 };

// Undo kludge above that avoids shifting .
cQuoteArab { collision.flags = CLEAR_IGNORE(collision.flags) };


// Never shift these!! (even though they are thought of as "nuqta-like" for some purposes).
cKafTop { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = CLEAR_FIX(collision.flags);
	};
	sequence.class = 0
};


if (collFix >= 3)

// For special cases:
////cKernable {collision {
////	flags = SET_FIX(collision.flags);
////	max.x = MAXKERN; min.x = MINKERN + minKernDelta;}}
////	/  _ {marginSet == 1}  cNuqtaLike?  DIACS  cPostKernable;

// Special case: alef + zabar-two-dots + kaf/gaf - cozy alef + zabar-two-dots up to kaf/gaf.
(cAlefIso cAlefFin) {
	collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		//margin = max(0m, kernLsb + @K.kernRsb + pairKern  - 100m);
		margin = 170m;
		max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
 	} }  /  _  gZabarTwoDots cKafIso=K;

// Zabar-two-dots must stay centered over the alef.
gZabarTwoDots {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = 60m;  // normally -250
		max.x = 60m;
		min.y = -100m;
		max.y = 100m;
		margin = 100m;  // cozy up
	} }  /  (cAlefIso cAlefFin)  _  gMaddaAbove? cBase;  // increase precedence

// Other diacritics should be more or less centered over alef.
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = 120m;  // normally -250
		max.x = 60m;
		min.y = -100m;
		max.y = 100m;
	} }  /  (cAlefIso cAlefFin)  _  gMaddaAbove? cBase;  // increase precedence

// Special cases
/**
cDiacriticUpper { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	// Don't set sequence attributes; let the diac stay below the upper nuqta.
}  /  cFehIni  cNuqtaLikeUpper  (cHehGoalMed cMeemMed)  cNuqtaLikeLower?  _;
**/

// Special case: the diac AP on the meem and heh-goal is pretty far to the right,
// so they need to move left after a feh. Using the sequencing mechanism messes things up,
// so turn it off for those.
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	////sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  / cFehIM  cNuqtaUpper  cDiacritic?  (cHehGoalMed  cMeemMed)  g__hehHook_small?  _;

// Special case: lam/kaf + meem + upper diac - move diac to the left
cDiacriticUpper {
	shift { x = 300m; y = -150m; };
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 250m;
		min.y = -300m;
		max.y = 200m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  (cLamIM cKafIM)  g__kafTop_null?  cNuqtaLikeLower?  cMeemMed  cNuqtaLikeLower?  _;

// Special case: upper diacritic before kaf cannot move very far left; in fact, shift it right
// Eg: \u0628\u06BE\u0627\u065E\u06AF\u06C1
cDiacriticUpper {
	shift.x = -200m;
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -100m; // less than normal
		max.x = 100m;  // 250
		min.y = -300m;
		max.y = 400m;  // less than normal
		// don't bother with sequence attributes
} }  /  (cMed  cIso) _  (cKafNoIso cKafIso);	

gNameMarker  { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -400m;
	max.x = 400m;
	min.y = -300m;
	max.y = 800m;
} };

chonorificDia { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	margin = 300m; marginweight = 500; // don't squeeze these in!
	min.x = -250m;
	max.x = 0m;
	min.y = -50m;
	max.y = 500m;
} };

gKharizabar {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -50m; 	// don't let them move too far to the left, away from the lam
		max.x = 10m;	// the lam is on the right, so don't move that direction.
		min.y = -50m;
		max.y = 50m;
		margin = 100m;
	}
} / (cLamIM gLamFin gLam) _ ;


// Diacritics attached to finals - allow them to move more to the left
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -400m;  // normally -250
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cFin  cNuqtaLikeLower?  _;

// Diacritics attached to bases:
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cBase  cNuqtaLikeLower?  _;


cDiacriticLower { 
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m; // making this larger than ideal fixes \u0628\u0650\u06CC\u062C
		max.x = 300m;
		min.y = -1200m; // needed to get below nuqtas for sure; eg \u062A\u0648\u0641\u0650\u06CC\u0642
		max.y = 300m;
	};
	sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; }
}  /  cBase  cNuqtaLikeUpper?  _;

// These should always stay centered over the nuqta if any:
(gNoonGhunnaMark g__smallV gKharizabar gKharizair gJazm) { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -10m;
	max.x = 10m;
	min.y = -300m;
	max.y = 500m;
} }  /  cNuqta  cDiacritic?  _;

cDiacriticUpper { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 250m;
	min.y = -300m;
	max.y = 500m;
} };


cDiacriticLower { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -300m; // making these larger than ideal fixes \u0628\u0650\u06CC\u062C
	max.x = 300m;
	min.y = -800m;
	max.y = 300m;
} };

endif; // (collfix >= 2) - shift fixes


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.

/******
if (overlapKern == none)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == wide)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
//	max.x = MAXKERN; min.x = MINKERN_TIGHT; margin = KERNMARGIN_MED;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == medium)
******/


// Don't let a single-letter word kern underneath following segment:
cIso { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
    // min/max.y are omitted for kernable glyphs
} }
	/  cSpace  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// Don't let an isolate alef kern too far - it's so thin that it looks odd and gets lost.
/****
gAlef { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = -275m + minKernDelta;    // = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=A  cNuqtaLike?  DIACS  cPostKernable=N;  // make context long enough for precedence 
****/


// EXPERIMENT - don't allow ANY overlap between words
//cKernable { collision {
//	flags = SET_FIX(collision.flags);
//	flags = SET_KERN(collision.flags);
//	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
//	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
//    // min/max.y are omitted for kernable glyphs
//} }
//	/  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// Special case; also see previous pass where nuqtas are shifted up
// \u063A\u0632\u06CC\u0631
cRehFin_longtail { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = 130m;
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=R  cNuqtaLike? cDiacritic?  (gBehIniRe gBehIniQf)  cDot3l cDiacritic? (gRehFin_jkl cWawFin);


// Special case: \u062A\u0627\u0631\u06CC\u062E\u06CC
// Don't allow the reh to kern underneath the lower nuqtas; also shift nuqtas up.
(gReh gRehDotBelow gWaw) { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = -400m;
    // min/max.y are omitted for kernable glyphs
} }
	cNuqtaLower {shift.y = 150m}
	/  _=R  gBehIniJm  _=N;

// Special case: \u06af\u0648\u064e\u0634\u062a\u0634
// Use a little less kerning and push the diacritic down.
(cWawFin cDalFin) { collision {
 		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = max(0m, kernLsb + @S.kernRsb + pairKern);
		max.x = MAXKERN; min.x = min(0m, MINKERN + minKernDelta + 100m);
    	// min/max.y are omitted for kernable glyphs
	} }
	cDiacriticUpper {shift.y = -200m}
	/  _=F  _=D  gSeenIniBeM1=S  MARKS  gBehMedSn  MARKS  gSeenFin;


cRehFin_longtail { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = 50m;
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=R  cNuqtaLike? cDiacritic?  (gBehIniRe gBehIniQf)  cNuqtaLikeLower cDiacritic? (gRehFin_jkl cWawFin);


// Don't kern glyphs before the high hamza; retain the space.
cKernable  (gHighHamza gHighHamzaArabic);

// Don't kern before numbers
cKernable  cKernIgnore?  cDigitAbsFullSize;

// For short sequences (two base chars) ending with bariyeh,
// kern against the bariyeh tail, not the initial.
cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags);  // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0, kernLsb + 90m);  // 90m = bariyeh's rsb
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cKernIgnore?  cIni cNuqtaLike? DIACS [cMed cNuqtaLike? DIACS]? 
		gBariyehFin=F;

// Special case: alef + kaf - set them a standard distance apart; don't use auto-kerning mechanism unless
// absolutely necessary.
(gAlef cAlefFin) { shift.x += -130m;
	collision {
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 150m;  // max(0m, kernLsb + @N.kernRsb + pairKern);
		max.x = MAXKERN; min.x = 0m; /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}  /  _  cNuqtaLike?  DIACS  cKernIgnore?  cKafIMF=K;

// Don't kern very much before closing quotes.
// PROBLEM: this rule is firing, but the resulting kerning never happens. Why? :-/
// TURN ON FOR BUG:
g_parenleftArab  { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @Q.kernRsb + pairKern);
	max.x = MAXKERN; min.x = min(0m, pairKern);
}}
	/  _  cNuqtaLike?  DIACS  cQuoteLeftArab=Q;



// Omit kerning altogether between punctuation.
cKernPunct { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 150m;   //// max(0m, kernLsb + @P.kernRsb + pairKern);
		max.x = MAXKERN; min.x = 0m; /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}   /  _  cKernPunct=P;

// Don't kern underneath a closing quote.
cKernable { collision.flags = CLEAR_KERN(collision.flags) }
	/	_  cNuqtaLike?  DIACS  cKernIgnore?  cQuoteLeftArab;


// Default cases:

cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = min(0m, MINKERN + minKernDelta);
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cKernIgnore?  cPostKernable=N;

cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


/******
endif; // overlapKern == medium

if (overlapKern == tight)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN_TIGHT;
    // min/max.y are omitted for kernable glyphs
} };

endif;
******/

// Digits can kern when they are next to each other.
cDigitAbsFullSize { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN_DIGIT + pairKern;
	max.x = MAXKERN; min.x = MINKERN;
} }  /  _ cDigitAbsFullSize;

cls_excludingGlyphs { collision { flags = CLEAR_FIX(collision.flags); exclude.glyph = 0 }};

// Note that most nuqtas will have been previously marked not-fix, unless they are contiguous to
// height-adjusted kafs.

/////cKernable { collision.flags = CLEAR_FIX(collision.flags) }; - if kerning is done earlier

endpass;  // pass 10

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.

if (collFix > 0)
pass(11) { CollisionFix = 4; AutoKern = true }
// Perform diacritic-related fixing.
endpass;
endif;

#endif // DO_COL_FIX


/////#include "awami_tweaks.gdh"

endtable;  // positioning

