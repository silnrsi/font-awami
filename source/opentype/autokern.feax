#
#	File: kerncalc.feax
#
# FEAX code for Awami Nastaliq

#	This file is part of the Awami Nastaliq font 
#	(https://software.sil.org/awami) and is 
#	Copyright (c) 2014-2024 SIL Global (https://www.sil.org/),
#	with Reserved Font Names "Awami" and "SIL".
#
#	This Font Software is licensed under the SIL Open Font License,
#	Version 1.1.
#
#	You should have received a copy of the license along with this Font Software.
#	If this is not the case, go to (https://openfontlicense.org/) for all the
#	details including an FAQ.

# This file is intended to be included in main.feax.

# Currently these lookups are run within feature calt. Eventually this might be changed to a stylistic set.

# lookup InitKernMetrics:
include(../../source/opentype/autoKernMetrics.feax);
###include(../../source/opentype/autoKernMetrics_100.feax);
###include(../../source/opentype/autoKernMetrics_200.feax);

# Don't allow kerning before bariyeh with overhanging tail.
lookup PreventPreBariyehKern {
	lookupflag UseMarkFilteringSet [@KwMarker @BariyehIsoForms @ByKernSpace];
	# Don't delete the kw0; other places in the system expect it to be present after a final.
	sub  kw0'  [@ByKernSpace @BariyehIsoForms]		by	kblock kw0;
} PreventPreBariyehKern;


# Kerning before isolates will be handled by hard-coding.
# We can do this because we always know their vertical position - that is, zero.
lookup PreventPreIsoKern {
	lookupflag UseMarkFilteringSet [@KwMarker];
	sub kw0'       				@Isolates	by	knoneIso kw0;
	sub kw0' space 				@Isolates	by	knoneIso kw0;
	sub kw0' space space 		@Isolates	by	knoneIso kw0;
	sub kw0' space space space	@Isolates	by	knoneIso kw0;
	# If we have lots of spaces, the kerning doesn't matter too much!
} PreventPreIsoKern;


# TODO: if we move TreatBasesAsMarks up, delete most of these rules.
lookup ClearAscentsPreIso {
	lookupflag UseMarkFilteringSet [@AscMarker knoneIso];
	rsub @AscMarker' knoneIso													by	ytIgnore;
	rsub @AscMarker' @AllBases knoneIso											by	ytIgnore;
	rsub @AscMarker' @AllBases @AllBases knoneIso								by	ytIgnore;
	rsub @AscMarker' @AllBases @AllBases @AllBases knoneIso						by	ytIgnore;
	rsub @AscMarker' @AllBases @AllBases @AllBases @AllBases knoneIso			by	ytIgnore;
	rsub @AscMarker' @AllBases @AllBases @AllBases @AllBases @AllBases knoneIso	by	ytIgnore;
} ClearAscentsPreIso;


# TODO: probably run TreatBasesAsMarks earlier and then delete this.
lookup IgnoreInvisibles {
	sub space by mkSpace;
	sub zerojoin by mkZerojoin;
	sub zeronojoin by mkZeronojoin;
} IgnoreInvisibles;


# Handle isolate forms explicitly. This is faster than running the algorithm.
lookup HardCodeIsolates {
	lookupflag UseMarkFilteringSet [@KwMarker];

	# alef
	sub [absRehFin._jkl]									kw0' lookup _Set200		@AlefIsoForms;
	sub [absRehFin]											kw0' lookup _Set100		@AlefIsoForms;
#	sub absRehFin._hgM - ignore
	sub [@RehIsoForms @DalFinForms @WawFinForms 
			@WawIsoForms]									kw0' lookup _Set100		@AlefIsoForms;

	# reh
	sub [@AlefIsoForms @AlefFinForms]						kw0' lookup _Set0		@RehIsoForms;
	sub [@WawIsoForms @WawFinForms]							kw0' lookup _Set200		@RehIsoForms;

	# seen & sad
	sub [@BehIsoForms @BehFinForms absFeh @FehFinForms]		kw0' lookup _Set200		[@SeenIsoForms @SadIsoForms];
	sub [@DalIsoForms @DalFinForms]							kw0' lookup _Set500		[@SeenIsoForms @SadIsoForms];
	sub [absReh absRehFin absRehFin._jkl]					kw0' lookup _Set400		[@SeenIsoForms @SadIsoForms];
	sub [absRehFin]											kw0' lookup _Set300		[@SeenIsoForms @SadIsoForms];
	sub [absZain]											kw0' lookup _Set200		[@SeenIsoForms @SadIsoForms];

	# kaf
	sub @AllBases			kw0' lookup _Set1000	[@KafIsoForms];

	# qaf
	sub absRehFin			kw0' lookup _Set100		absQafFin;

	# waw
	sub [@DalIsoForms]		kw0' lookup _Set100		@WawIsoForms;	

} HardCodeIsolates;

lookup HardCodeIsolatesWNuqtaUpper {
	lookupflag UseMarkFilteringSet [@KwMarker @NuqtaLikeUpper];
} HardCodeIsolatesWNuqtaUpper;

# Insert "extra ascent/descent" markers into the stream to represent the presence
# of nuqtas and/or marks. These cause the ascent to be raised higher or the
# descent to be lowered.
lookup HandleMarkAsc {
	lookupflag UseMarkFilteringSet [@PyInitMarker @NuqtaLikeUpper @DiacUpper ytIgnore];

	ignore sub @PyInitMarker' ytIgnore;		# we're ignoring the ascents - because this is a segment preceding an isolate

	sub @PyInitMarker' lookup _InsertNuqtaDiacMarker	@DiacUpper;
	sub	@PyInitMarker' lookup _InsertNuqtaDiacMarker	@NuqtaLikeUpper;
} HandleMarkAsc;

lookup HandleMarkDsc {
	lookupflag UseMarkFilteringSet [@PyInitMarker @NuqtaLikeLower @DiacLower];
	sub @PyInitMarker' lookup _InsertNuqtaDiacMarker	@DiacLower;
	sub @PyInitMarker' lookup _InsertNuqtaDiacMarker	@NuqtaLikeLower;
} HandleMarkDsc;

# Special cases: the nuqta doesn't affect the height of the entire (wide) glyph.
# Only raise the height where the nuqta is positioned.
lookup HandleAscMarkLimited {
	lookupflag UseMarkFilteringSet [@AllBases @NuqtaLikeUpper @AscXMarker];

	# Ideally these should be treated like the qaf below, but in fact the final seen and feh forms
	# are wide enough that the nuqtas on the right side are never going to affect kerning, which
	# is limited to 1200 units.
	sub [absFehFin absSeenFin]			ascx600'	@NuqtaLikeUpper		by	ascx.Done;
	sub [absFehFin absSeenFin]			ascx1000'	@NuqtaLikeUpper		by	ascx.Done;

	sub [absQafFin absQafFin_short]		ascx600'	@NuqtaLikeUpper		by	ascx600.Rt8;
	sub [absQafFin absQafFin_short]		ascx1000'	@NuqtaLikeUpper		by	ascx1000.Rt8;

	sub [absBehFin absBehFin._bfkl]		ascx600'	@NuqtaLikeUpper		by	ascx600.Mid8;
	sub [absBehFin absBehFin._bfkl]		ascx1000'	@NuqtaLikeUpper		by	ascx1000.Mid8;
} HandleAscMarkLimited;

lookup AdjustAscxDscx4Shifts {
	lookupflag UseMarkFilteringSet [@DscXMarker @CfMarkerNS];

	# The nuqtas have been shifted (in lookup CollFix), so adjust the vertical deltas accordingly.
	# TODO: add more values as needed.

	# sub dscx600' lookup _IncAscxDscx100 cfN100;

	sub [@AscXMarker @DscXMarker]' lookup _IncAscxDscx100 cfN100;
	sub [@AscXMarker @DscXMarker]' lookup _IncAscxDscx200 cfN200;

	sub [@AscXMarker @DscXMarker]' lookup _DecAscxDscx100 cfS100;
	sub [@AscXMarker @DscXMarker]' lookup _DecAscxDscx200 cfS200;
} AdjustAscxDscx4Shifts;


# Turn bases into marks so we can filter them out of all the arithmetic.
lookup TreatBasesAsMarks {
	lookupflag IgnoreMarks;
	# sub @KernBase by  @KernBaseMark;  # FEAX doesn't handle classes with different structures
	sub @Initials		by	@KernBaseMarkIni;
	sub @Medials		by	@KernBaseMarkMed;
	sub @KernFinals		by	@KernBaseMarkFin;
	sub @Isolates		by	@KernBaseMarkIso;
	sub @KernBaseOther	by	@KernBaseMarkOther;
} TreatBasesAsMarks;


# Must come after InitKernMetrics.
# Adjust the YbMarkers and the initial kern value to account for nuqtas that hang
# out to the right of the initial base (eg, peh, yeh) and kaf/gaf diagonal strokes.
# TODO: Replace some of these rules with ones that test for the presence CfMarkerEWs.
lookup AdjustForLowerNuqtaOverhang {
	# @KernBaseMarkVis ignores spaces
	lookupflag UseMarkFilteringSet [@KwMarker @KernBaseMarkVis ybLast @NuqtaLikeLower];

	# beh + beh + final jeem
	sub @KwMarker' lookup _DecKwBy600	[mkBehIni.be]'		ybLast' lookup _ExtendYbBy600	@DotTallL
			mkBehMed.jm ybLast @DotWideL	mkJeemFin;
	sub @KwMarker' lookup _DecKwBy500	[mkBehIni.be]'		ybLast' lookup _ExtendYbBy500	@DotWide
			mkBehMed.jm ybLast @NuqtaLikeLower	mkJeemFin;
	sub @KwMarker' lookup _DecKwBy500	[mkBehIni.be]'		ybLast' lookup _ExtendYbBy500	@DotWide
			mkBehMed.jm ybLast	mkJeemFin;
	sub @KwMarker' lookup _DecKwBy300	[mkBehIni.be]'		ybLast' lookup _ExtendYbBy300	@DotNarrow
			mkBehMed.jm ybLast @NuqtaLikeLower	mkJeemFin;
	sub @KwMarker' lookup _DecKwBy300	[mkBehIni.be]'		ybLast' lookup _ExtendYbBy300	@DotNarrow
			mkBehMed.jm ybLast	mkJeemFin;

	# jeem + final ain
	sub @KwMarker' lookup _DecKwBy100	mkJeemIni.ai'		ybLast' lookup _ExtendYbBy100	@DotWideL	mkAinFin;

	# beh initials - lower
	sub @KwMarker' lookup _DecKwBy300	[mkBehIni.be]'				ybLast' lookup _ExtendYbBy300	@DotWideL	mkBehMed.hgM;
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.be]'				ybLast' lookup _ExtendYbBy100	@DotNarrowL	mkBehMed.hgM;
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.be mkBehIni.beM1
										 mkBehIni.benn]'			ybLast' lookup _ExtendYbBy100	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.beM2]'			ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.beM2]'			ybLast' lookup _ExtendYbBy100	@DotNarrowL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.re]'				ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy300	[mkBehIni.jm]'				ybLast' lookup _ExtendYbBy300	@DotWideL  @KernBaseMarkMed;  # followed by medial
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.sn mkBehIni.sd]'	ybLast' lookup _ExtendYbBy100	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.ai]'				ybLast' lookup _ExtendYbBy200	@DotWideL  @KernBaseMarkMed;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.mm ]'				ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy300	[mkBehIni.mmX mkBehIni.ch ]' ybLast' lookup _ExtendYbBy300	@DotNarrowL;
	sub @KwMarker' lookup _DecKwBy600	[mkBehIni.mmX mkBehIni.ch ]' ybLast' lookup _ExtendYbBy600	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.hd]'				ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.nn]'				ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.qf]'				ybLast' lookup _ExtendYbBy100	@DotNarrowL;
	sub @KwMarker' lookup _DecKwBy400	[mkBehIni.qf]'				ybLast' lookup _ExtendYbBy400	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.bere]'			ybLast'	lookup _ExtendYbBy200	@DotWideL;

	# beh+beh - the nuqta on the second beh is an issue
	# sub @KwMarker' lookup _DecKwBy400	mkBehIni.beM1'					ybLast' lookup _ExtendYbBy400	@NuqtaLike
	# 	@BehKernBaseMarkMed  @DotWideL;

	# jeem initials - lower
	sub @KwMarker' lookup _DecKwBy100	[mkJeemIni.re]'					ybLast' lookup _ExtendYbBy100	@DotWideL;
	sub @KwMarker' lookup _DecKwBy600	[mkJeemIni.jm]'					ybLast' lookup _ExtendYbBy600	@DotWideL @KernBaseMarkMed;  # followed by medial
	sub @KwMarker' lookup _DecKwBy200	[mkJeemIni.jm]'					ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy400	[mkJeemIni.ch]'					ybLast' lookup _ExtendYbBy400	@DotWideL;
	sub @KwMarker' lookup _DecKwBy100	[mkJeemIni.fe]'					ybLast' lookup _ExtendYbBy100	@DotWideL  @KernBaseMarkMed;
	sub @KwMarker' lookup _DecKwBy200	[mkJeemIni.mm mkJeemIni.mmX]'	ybLast' lookup _ExtendYbBy200	@DotNarrowL;
	sub @KwMarker' lookup _DecKwBy400	[mkJeemIni.mm mkJeemIni.mmX]'	ybLast' lookup _ExtendYbBy400	@DotWideL;
	sub @KwMarker' lookup _DecKwBy100	[mkJeemIni.qf mkJeemIni.ch]'	ybLast' lookup _ExtendYbBy100	@DotNarrowL;
	sub @KwMarker' lookup _DecKwBy300	[mkJeemIni.qf]'					ybLast' lookup _ExtendYbBy300	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkJeemIni.ai]'					ybLast' lookup _ExtendYbBy200	@DotWideL  @KernBaseMarkMed;
	sub @KwMarker' lookup _DecKwBy100	[mkJeemIni.hd]'					ybLast' lookup _ExtendYbBy100	@DotWideL;
	sub @KwMarker' lookup _DecKwBy400	[mkJeemIni.ch]'					ybLast' lookup _ExtendYbBy400	@DotWideL;

	# feh w/ three dots below
	sub @KwMarker' lookup _DecKwBy300	[mkFehIni.jm]'					ybLast' lookup _ExtendYbBy300	@DotWideL  @KernBaseMarkMed;
	sub @KwMarker' lookup _DecKwBy100	[mkFehIni.fe]'					ybLast' lookup _ExtendYbBy100	@DotWideL  @KernBaseMarkMed;
	sub @KwMarker' lookup _DecKwBy100	[mkFehIni.sn]'					ybLast' lookup _ExtendYbBy100	@DotWideL;
	sub @KwMarker' lookup _DecKwBy300	[mkFehIni.mmX mkFehIni.hgM]'	ybLast' lookup _ExtendYbBy300	@DotWideL;
	sub @KwMarker' lookup _DecKwBy400	[mkFehIni.mm mkFehIni.hd]'		ybLast' lookup _ExtendYbBy400	@DotWideL;
	sub @KwMarker' lookup _DecKwBy200	[mkFehIni.nn mkFehIni.qf]'		ybLast' lookup _ExtendYbBy200	@DotWideL;
	sub @KwMarker' lookup _DecKwBy500	[mkFehIni.ch]'					ybLast' lookup _ExtendYbBy500	@DotWideL;

	# ... beh+heh-goal
	sub @KwMarker' lookup _DecKwBy100	[mkBehIni.hgM]'					ybLast' lookup _ExtendYbBy100	@DotWideL;

} AdjustForLowerNuqtaOverhang;

lookup AdjustForUpperNuqtaOverhang {
	# @KernBaseMarkVis ignores spaces
	lookupflag UseMarkFilteringSet [@KwMarker @KernBaseMarkVis ybLast @NuqtaLikeUpper _bar];
	
	# beh initials - upper
	# TODO - since this is an upper nuqta, really we should extend a number higher than the actual glyph bottom.
	sub @KwMarker' lookup _DecKwBy100	mkBehIni'			ybLast'	lookup _ExtendYbBy100	@DotWideU;
	sub @KwMarker' lookup _DecKwBy200	[mkBehIni.benn
										 mkBehIni.beM1]'	ybLast'	lookup _ExtendYbBy200	@DotWideU;


	# TODO: strictly speaking, we shouldn't extend the bottom of the lam but some point in the middle, and
	# by considerably more than 100. But this is better than nothing.
	sub @KwMarker' lookup _DecKwBy100	[mkLamBar]'						ybLast' lookup _ExtendYbBy100;
	sub @KwMarker' lookup _DecKwBy100	[mkLamIni mkLamIni.be mkLamIni.beM1 mkLamIni.beM2 mkLamIni.re
										mkLamIni.benn mkLamIni.behg mkLamIni.bere mkLamIni.jm mkLamIni.sn
										mkLamIni.snsn mkLamIni.sd mkLamIni.ta mkLamIni.ai mkLamIni.fe mkLamIni.mm
										mkLamIni.hd mkLamIni.hgM mkLamIni.hgF mkLamIni.nn mkLamIni.qf
										mkLamIni.ch]'					ybLast' lookup _ExtendYbBy100	[_bar];
} AdjustForUpperNuqtaOverhang;

# Add another slice or two if the nuqta of interest has been shifted right (east).
lookup AdjustForNuqtaShift {
	lookupflag UseMarkFilteringSet [@KwMarker @ExtYbMarker ybLast @NuqtaLikeLower @CfMarkerEW];
	sub @KwMarker' lookup _DecKwBy100	@ExtYbMarker' lookup _ExtendYbBy100	ybLast'	@NuqtaLikeLower	cfE100;
	sub @KwMarker' lookup _DecKwBy200	@ExtYbMarker' lookup _ExtendYbBy200	ybLast' @NuqtaLikeLower	cfE200;
} AdjustForNuqtaShift;


lookup AdjustForNuqtaOnFinal {
	lookupflag UseMarkFilteringSet [@PyMarker @KernBaseMarkVis @KwMarker @NuqtaLikeUpper];

	# final reh
	sub [mkRehFin mkRehFin._hgM]	@PyMarker	kw0'  [@DotWideU _smallTah]		by	kwN300;
	sub [mkRehFin mkRehFin._hgM]	@PyMarker	kw0'  @NuqtaLikeUpper			by	kwN200;
} AdjustForNuqtaOnFinal;

# Bases such as the final jeem and ain have swashes that curve right. In short sequences
# these need kerning.
lookup AdjustForBaseOverhang {
	lookupflag UseMarkFilteringSet [@KernBaseMarkWord @KwMarker];
	sub @KwMarker' lookup _IncKwBy800		mkKehehIni.sd';

	# 2-char sequences with overhang on right
	# sub mkRehFin	@KwMarker' lookup _DecKwBy600		@KernBaseMarkIni	[mkJeemFin mkAinFin];  # was 800
	
	# 2-char sequences w/ final jeem
	ignore sub @KwMarker' 		[mkSadIni.jm mkHehDoachashmeeIni.jm]	mkJeemFin;
	ignore sub @KwMarker' 					@KafKernBaseMarkIni			mkJeemFin;
	sub @KwMarker' lookup _DecKwBy400		[mkSadIni.jm]				mkJeemFin;
	sub @KwMarker' lookup _DecKwBy500		@KernBaseMarkIni			mkJeemFin;

	# 2-char sequences w/ final ain
	sub @KwMarker' lookup _DecKwBy400		[mkBehIni.ai mkFehIni.ai mkLamIni.ai]	mkAinFin;

	# Short sequences ending with jeem+jeem.
	# Not kerned yet:
	#    \/
	sub kw0' lookup _DecKwBy200	mkBehIni.jm		mkJeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy200	mkLamIni.jm		mkJeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy300	mkJeemIni.jm	mkJeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy300	mkFehIni.jm		mkJeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy300	mkMeemIni.jm	mkJeemMed.jm	mkJeemFin;

	# ... meem+jeem
	# sub kw0' lookup _DecKwBy100	mkBehIni.jm		mkJeemMed.jm	mkJeemFin;  - ok
	sub kw0' lookup _DecKwBy300	mkLamIni.mm		mkMeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy500	mkFehIni.mm		mkMeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy300	mkMeemIni.mm	mkMeemMed.jm	mkJeemFin;

	# ... feh+jeem
	sub kw0' lookup _DecKwBy200	mkLamIni.mm		mkMeemMed.jm	mkJeemFin;
	sub kw0' lookup _DecKwBy200	mkFehIni.mm		mkMeemMed.jm	mkJeemFin;

} AdjustForBaseOverhang;


# Measure heights

# Note that @PyMarker does NOT include pyNull, which is what forces the backwards processing.

lookup MeasureBaseY {
	lookupflag UseMarkFilteringSet @YMarkers;
	# rsub pyNULL' dy100 py0  by  py100;
	# rsub pyNULL' dy100 py100  by  py200;
	# rsub pyNULL' dy100 py200  by  py300;
	# etc.
include(../../source/opentype/arithMeasureYrules.feax);
} MeasureBaseY;


@AscXPartialMarkers = [ascx600.Rt8 ascx1000.Rt8 ascx600.Mid8 ascx1000.Mid8];

# NB: asc/dsc -> pt/pb
# We include the @PyMarker to recognize the boundaries of the bases.
lookup AddNuqtaAscent {
	lookupflag UseMarkFilteringSet [@PyMarker @AscMarker @AscXMarker @AscXPartialMarkers];

	# Special cases: on some forms, the nuqta doesn't add height all the way across the glyph, only on the right side.
	# e.g., qaf, feh, seen
	sub @PyMarker ascx600.Rt8' lookup _AscxDone
			@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600 
			@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600
			@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600
			@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600;
	sub @PyMarker ascx1000.Rt8' lookup _AscxDone
			@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000 
			@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000
			@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000
			@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000;

	# E.g., final theh
	sub @PyMarker ascx600.Mid8' lookup _AscxDone
			@AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' 
	 		@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600 
	 		@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600
	 		@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600
	 		@AscMarker' lookup _AddNuqtaHt600	@AscMarker' lookup _AddNuqtaHt600;
	sub @PyMarker ascx1000.Mid8' lookup _AscxDone
			@AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' @AscMarker' 
	 		@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000 
	 		@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000
	 		@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000
	 		@AscMarker' lookup _AddNuqtaHt1000	@AscMarker' lookup _AddNuqtaHt1000;

	# Default case: add across the whole width of the glyph.
	sub @PyMarker @AscXMarker @AscMarker' lookup _AddNuqtaUpperHt;
} AddNuqtaAscent;

lookup SubtractNuqtaDescent {
	lookupflag UseMarkFilteringSet [@PyMarker @DscMarker @DscXMarker @NuqtaLike];
	sub @PyMarker @DscXMarker @DscMarker' lookup _SubtractNuqtaLowerHt;
} SubtractNuqtaDescent;

include(../../source/opentype/arithTopLevel.feax);
# -----------------    ^^^ This file includes the following:

# Convert markers pt/pb back to asc/dsc
# lookup MarkersYtb2AscDsc:

# These are flattened for the sake of performance.
# lookup MakeAscentAbsolute;
#  lookupflag UseMarkFilteringSet [@PyMarker @AscMarker];
#  sub py0  asc100' lookup _Set100;
#  sub py0  asc200' lookup _Set200;
#  sub py0  asc300' lookup _Set300;
#  ...
#} MakeAscentAbsolute;

# lookup MakeDescentAbsolute;
#  lookupflag UseMarkFilteringSet [@PyMarker @DscMarker];
#  sub py0  dscN1500' lookup _SetN1500;
#  sub py0  dscN1400' lookup _SetN1400;
#  sub py0  dscN1300' lookup _SetN1300;
#  ...
#} MakeDescentAbsolute;

# ---------------

# Extend the slices below to account for the width of an overhanging nuqta.
lookup ExtendForNuqtaOverhang {
	lookupflag UseMarkFilteringSet [@YbMarker @ExtYbMarker];
	do	forlet ybm = feaclass('YbMarker');
	{
		sub $ybm extYb1' by $ybm;
		sub $ybm extYb2' by $ybm $ybm;
		sub $ybm extYb3' by $ybm $ybm $ybm;
		sub $ybm extYb4' by $ybm $ybm $ybm $ybm;
		sub $ybm extYb5' by $ybm $ybm $ybm $ybm $ybm;
		sub $ybm extYb6' by $ybm $ybm $ybm $ybm $ybm $ybm;
	}
} ExtendForNuqtaOverhang;

lookup MedialNuqtaOverhang {

} MedialNuqtaOverhang;

# Now actually do the comparisons to calculate the amount of kerning that is possible.

# Each CalculateKern lookup below works backward by one slice in the sequence to be kerned,
# kerning a little more tightly if possible.
# The EnforceBlock checks to see if we are blocked and forces the process to terminate.
# These lookups need to be separate because they use different filters.
# We need this set of lookups for every potential kerned slice. Right now
# we are allowing 12.

# TODO: the last four lookups are not needed for the final iteration.

do	forlet n = range(0,6);
	let c = str(n + 1);
	let ln_CalculateKern = "CalculateKern" + c;
	let ln_EnforceBlock = "EnforceBlock" + c;
	let ln_CleanUpKernedGlyph = "CleanUpKernedGlyph" + c;
	let ln_CleanUpTopGlyph = "CleanUpTopGlyph" + c;
	let ln_ShiftPrevGlyph = "ShiftPrevGlyph" + c;
	let ln_ShiftNextGlyph = "ShiftNextGlyph" + c;

{

lookup $ln_CalculateKern {
	lookupflag UseMarkFilteringSet [@KwMarker @PyMarker @YtMarker @YbMarker @KBlock];

#	sub  @YtMarker'  lookup _TryKern	@KwMarker   @YbMarker;

	sub @YtMarker' lookup _TryKernShift	@KwMarker'  @PyMarker'  @YbMarker';		# first shift

	sub @YtMarker  @YtMarker' lookup _TryKernShift  @YbMarker';					# subsequent shifts

} $ln_CalculateKern;

lookup $ln_EnforceBlock {
	lookupflag UseMarkFilteringSet [@KwMarker @KBlock @KernBaseMarkIsoIniFin];
	sub @KBlock' @KwMarker' lookup _EnforceBlock;
	sub @KwMarker' lookup _EnforceBlock;
} $ln_EnforceBlock;

# Once a (final) glyph has been completely kerned, invalidate its bottoms.
# TODO: extend to kern 3 glyphs; currently it only handles 2.
lookup $ln_CleanUpKernedGlyph {
	lookupflag UseMarkFilteringSet [@YbMarker @KwMarker @YtMarker @KBlock @KNone];
	#ignore rsub @YbMarker'  kblock  @KwMarker;  # implied by filter that includes @KBlock or KNone
	rsub @YbMarker' @KwMarker	by  ybIgnore;
} $ln_CleanUpKernedGlyph;

# Currently this handles kerning under 3 glyphs max.
# Once a glyph has had something kern under it completely, invalidate its tops.
# TODO: find a way to stop this running if there is a kblock present.
lookup $ln_CleanUpTopGlyph {
	lookupflag UseMarkFilteringSet [@YbMarker @YtMarker ybLast @KwMarker @KBlock @KNone];
	sub @YbMarker @YtMarker ybLast			@YtMarker'  @KwMarker	by  ytIgnore;
	sub @YbMarker @YtMarker ybLast ybLast	@YtMarker'  @KwMarker	by  ytIgnore;  # second glyph in sequence
} $ln_CleanUpTopGlyph;

# Shift a single @YbMarker from the previous glyph into the final, so we can test it for kerning.
# TODO: extend to kern 3 glyphs; currently it only handles 2.
lookup $ln_ShiftPrevGlyph {
	lookupflag UseMarkFilteringSet [@YtMarker @PyMarker @KwMarker @KBlock @KNone]; # the @PyMarker delineates a separate glyph
	#ignore sub @YtMarker' @PyMarker' kblock' @KwMarker';  # implied by filter that includes @KBlock - same with @KNone
	sub @YtMarker' lookup _ShiftFromPrev @PyMarker' @KwMarker';
} $ln_ShiftPrevGlyph;

# Shift a single @YbMarker from the following glyph into the initial, so we can test for kerning under it.
# Currently this handles kerning under 3 glyphs max.
# TODO: don't run if there is a kblock or knone present.
lookup $ln_ShiftNextGlyph {
	lookupflag UseMarkFilteringSet [ybLast @KwMarker @PyMarker @YbMarker @YtMarker @KBlock @KNone];
	sub @YtMarker ybLast' lookup _ShiftFromNext	@PyMarker'						@YbMarker';
	sub @YtMarker ybLast' lookup _ShiftFromNext	@PyMarker' ybLast'	@PyMarker'	@YbMarker';
} $ln_ShiftNextGlyph;

}
# end of do


# If a block occurred, reduce the amount of kerning a bit to avoid an actual collision.
lookup AddSpaceWhenBlocked {
	sub kblock	@KwMarker' lookup _DecKwBy100;

} AddSpaceWhenBlocked;


lookup IniKafKern {
	lookupflag UseMarkFilteringSet [@KwMarker @KernBaseMarkVis];

	# Account for jeem and ain back-swashes.
	sub @KernBaseMarkIsoFin		kw1200'		@KafKernBaseMarkIni		[mkJeemFin mkAinFin]	by	kw300;		# eg, noon
	sub @KernBaseMarkIsoFin		kw400'		@KafKernBaseMarkIni		[mkJeemFin mkAinFin]	by	kw0;
	sub @KernBaseMarkIsoFin		kw500'		@KafKernBaseMarkIni		[mkJeemFin mkAinFin]	by	kw200;		# eg, heh-goal
	sub @KernBaseMarkIsoFin		kw600'		@KafKernBaseMarkIni		[mkJeemFin mkAinFin]	by	kw300;		# eg, lam-alef
	sub @KernBaseMarkIsoFin		kw700'		@KafKernBaseMarkIni		[mkJeemFin mkAinFin]	by	kw400;

	# Thin single chars need a little extra kerning before the kaf, because short sequences can't kern more than their width.
	# TODO: handle other forms of these isolates
	sub mkHehGoal	kw500'  [@KafKernBaseMarkIni @KafKernBaseMarkIso]		by	kw700;
	sub mkAlef		kw300'  [@KafKernBaseMarkIni @KafKernBaseMarkIso]		by	kw500;
	sub mkWaw		kw700'  [@KafKernBaseMarkIni @KafKernBaseMarkIso]		by	kw900;
	sub mkDal		kw800'  [@KafKernBaseMarkIni @KafKernBaseMarkIso]		by	kw1000;
	sub mkReh		kw800'  [@KafKernBaseMarkIni @KafKernBaseMarkIso]		by	kw1100;

} IniKafKern;


lookup HandFix {
	# Cases that are easiest to hard-code.
	lookupflag UseMarkFilteringSet [@KernBaseMarkVis @NuqtaLikeUpper @KwMarker];

	sub [mkAlef mkAlefMaddaAbove mkAlefFin mkAlefFin._lm]	kw0'  mkBehIni	@NuqtaLikeUpper	mkAlefFin	by	kwN200;

} HandFix;


lookup RestoreBases {
	lookupflag UseMarkFilteringSet @KernBaseMark;
	# sub @KernBaseMark  by  @KernBase;  # FEAX doesn't handle classes with different structures
	sub @KernBaseMarkIni	by	@Initials;
	sub @KernBaseMarkMed	by	@Medials;
	sub @KernBaseMarkFin	by	@KernFinals;
	sub @KernBaseMarkIso	by	@Isolates;
	sub @KernBaseMarkOther	by	@KernBaseOther;
} RestoreBases;



# Leaving the markers in for the time being helps with debugging.
# lookup CleanUpMarkers {
# 	lookupflag UseMarkFilteringSet [@DyMarker @YtMarker @YbMarker @KBlock @PyMarker];
# 	sub @DyMarker by NULL;
# 	sub @YtMarker by NULL;
# 	sub @YbMarker by NULL;
# 	sub @KBlock by NULL;
# 	sub @PyMarker by NULL;
#   sub ybIgnore by NULL;
#   sub ytIgnore by NULL;
#	# Whatever we do, don't delete KwMarkers or CfMarkers!
# } CleanUpMarkers;
