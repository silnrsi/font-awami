//
//	File: nastaliq_rules.gdl
//
//	Graphite positioning rules for Awami Nastaliq

/*
	This file is part of the Awami Nastaliq font 
	(http://software.sil.org/awami) and is 
	Copyright (c) 2014-2022 SIL International (http://www.sil.org/),
	with Reserved Font Names "Awami" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including an FAQ.
*/

// Does full stop, comma, etc kern like a base char? (Using a flag here until we decide for sure what behavior we want.)
#define KERNLOWPUNCT 1


table(glyph)
cLowPunct = ( gComma gFullStop gSemicolon g_colonArab g_ellipsisArab );
cHighPunct = ( g_exclamArab gQuestionMark g_parenleftArab g_parenrightArab
	g_quoteleftArab g_quoterightArab g_quotedblleftArab g_quotedblrightArab g_quotedblArab g_quotesingleArab );
cKernPunct = ( cLowPunct  cHighPunct );
endtable;


table(positioning)

pass(1)  // 8

//
//	CURSIVE ATTACHMENT
//

#define cursive_attach(P)  c_exit_##P {att {to=@L; with=exit_##P; at=entr_##P}} c_entr_##P {insert=1} / _ MARKS2N ^ _=L ;

// Only used for beh so we don't need to allow upper and lower diacs:
// E.g.,
////	c_exit_behLowTooth {att {to=@L; with=exit_behLowTooth; at=entr_behPreFinalHehGoal}} 
////		c_entr_behPreFinalHehGoal {insert=1} 
////			/ _ MARKS ^ _=L ;

#define cursive_attach2(P1, P2)  c_exit_##P1 {att {to=@L; with=exit_##P1; at=entr_##P2}} c_entr_##P2 {insert=1} / _ MARKS ^ _=L ;


#if (QUICKCOMPILE == 0)

// The sequence width is used to determine kerning limits (for instance, avoiding kerning
// a very short sequence under a longer/higher sequence). It will not be completely
// accurate if glyphs of a different width are later substituted.
#define seqWidth user5

c_exit { att {to=@N; with=exit; at=entrance} } 
	c_entrance { insert=1; 
			seqWidth = @P.advance.x + @P.seqWidth  // for measuring sequences
		} 
		/ _=P MARKS2N ^ g_zerojoin? _=N ;

// For measuring sequences. Note that the longer the sequence length, the more it 
// can be kerned under the following sequence.
cRehFin { seqWidth += advance.x - 300m };     // I don't understand why 300 makes these work more similarly to the others
cFin { seqWidth += advance.x };
cIso { seqWidth += @P.advance.x + @P.seqWidth }		  // no space - same sequence
	/  (cIso cFin)=P MARKS2N  _=N;       
cIso { seqWidth = advance.x };                          // start a new sequence after space or at very beginning

#if KERNLOWPUNCT
// low punctuation should be treated as part of the word sequence
cLowPunct { seqWidth += @P.advance.x + @P.seqWidth }   
	/  (cIso cFin)=P MARKS2N  _=N; 
#endif
  
/***
cursive_attach(alef)
cursive_attach(beh)
cursive_attach(behFinal)
cursive_attach(behHighTooth)
cursive_attach(behLowTooth)
cursive_attach2(behLowTooth, behPreFinalHehGoal)
// Special cases not handled by macro due to attached-ring:
c_exit_behLowTooth {att {to=@L; with=exit_behLowTooth; at=entr_behPreFinalHehGoal}} 
	c_entr_behPreFinalHehGoal {insert=1} 
	/ _  g__kafTop_null  (g__attachedRingMid g__grafStroke) ^ _=L ;
cursive_attach(behPreReh)
cursive_attach(behPreNoon)
cursive_attach(jeem)
cursive_attach(reh)
cursive_attach(rehHgm)
cursive_attach(rehJkl)
//cursive_attach(rehSshg)
cursive_attach(seen)
cursive_attach(sad)
cursive_attach(tah)
cursive_attach(ain)
cursive_attach(feh)
cursive_attach(meem)
cursive_attach(meemAlt)
cursive_attach(noon)
cursive_attach(hehgoalMedial)
cursive_attach(hehgoalFinal)
cursive_attach(hehdoach)
cursive_attach(chotiyeh)
cursive_attach(chotiyehBfkl)
cursive_attach(bariyeh)
cursive_attach(lamKaf)
cursive_attach(qafWaw)
cursive_attach(qafWawStfh)
***/

//  c_exit_qafWawStfh {  attach {to = @6; with = exit_qafWawStfh; at = entr_qafWawStfh; }  }  c_entr_qafWawStfh { insert = 1;  }  
//              /  _  cNuqtaLikeLower  cNuqtaLikeUpMid  cDiacritic  cDiacritic  ^  _  ;" >


#endif  // QUICKCOMPILE

// EXPERIMENTS
#define SHIFT_N_OUT 0m

// Last resort:
cIniMed {att.to=@L}  cMedFinZJ {insert=1}  / _ MARKS2N ^ _=L ;

// Note that this will not affect the width of visible spaces.

if (wordSpacing == xtight)
g_narrowNoBreakSpace { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace       { advance.x = 75m; collision.flags = SET_ISSPACE(collision.flags) };
// Don't change these spaces; they are based on the em-square.
//g_hairSpace          { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
//g_thinSpace          { advance.x = 60m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == tight)
g_narrowNoBreakSpace { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace       { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
//g_hairSpace          { advance.x = 10m; collision.flags = SET_ISSPACE(collision.flags) };
//g_thinSpace          { advance.x = 100m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == medium)
g_narrowNoBreakSpace { advance.x = 75m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace       { advance.x = 225m; collision.flags = SET_ISSPACE(collision.flags) };
//g_hairSpace          { advance.x = 60m; collision.flags = SET_ISSPACE(collision.flags) };
//g_thinSpace          { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == wide)
g_narrowNoBreakSpace { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace       { advance.x = 300m; collision.flags = SET_ISSPACE(collision.flags) };
//g_hairSpace          { advance.x = 120m; collision.flags = SET_ISSPACE(collision.flags) };
//g_thinSpace          { advance.x = 2250m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == xwide)
g_narrowNoBreakSpace { advance.x = 225m; collision.flags = SET_ISSPACE(collision.flags) };
cStdWidthSpace       { advance.x = 375m; collision.flags = SET_ISSPACE(collision.flags) };
//g_hairSpace          { advance.x = 175m; collision.flags = SET_ISSPACE(collision.flags) };
//g_thinSpace          { advance.x = 300m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

// obsolete feature:
//(cVisSpace  cshowInv  g_zeroWidthNoBreakSpaceShowInv_alt cShowInvBoxes cEmbedMarkers)
//	{ collision.flags = SET_ISSPACE(collision.flags) };

endpass;  // 1 (8)

endtable;	// positioning


// TEMPORARY
table(glyph)

cIni { zeroS = point(0m, 0m) };
cMed { zeroS = point(0m, 0m) };
cFin { zeroS = point(0m, 0m) };

cNuqtaLike { zeroM = point(0m, 0m); zeroS = point(0m, 0m) };

cDiacritic { zeroM = point(0m, 0m) };

endtable;


//
//  NUQTA ATTACHMENT
//

table(positioning)

pass(2)  // 9

// Use wider spaces for Latin text.
cSpace {advance.x += 200m}  /  _  cLatin;
cSpace {advance.x += 200m}  /  cLatin  _;


// Upper and lower nuqta attachment

table(glyph)

// For some reason I have to subtract something to make these things work. :-/
cn1LowerDia { nByLowerM = point(n1LowerM.x, n1LowerM.y - 1m) };
cn23LowerDia { nByLowerM = point(n23LowerM.x, n23LowerM.y - 1m) };

cTakes_nLowerDia = (cTakes_n1LowerDia cTakes_n23LowerDia);

// For attaching any kind of nuqta-like thing...
cHasUpperMaux = (cNuqtaUpper, gHamzaAbove, g__hamzaArabic, g__smallTah, g__smallTah2dots, g__smallV);
cNuqtaUpper { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };
gHamzaAbove { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__hamzaArabic  { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__smallTah { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallTah2dots { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallV  { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };

// To avoid compiler warnings:
gArabicKafTwoDotsAbove { nUpperS = mUpperS };


// Intersection classes:

cTakes_hamzaAndN23LowerDia = cTakes_n23LowerDia;
cTakes_hamzaAndN23LowerDia &= cTakes_hamzaUpperDia;

cTakes_hamzaAndHehhookDia = cTakes_hamzaUpperDia;
cTakes_hamzaAndHehhookDia &= cTakes_hehhookDia;

cTakes_ringAndNUpperDia = cTakes_nUpperDia;
cTakes_ringAndNUpperDia &= cTakes_ringDia;

endtable;  // glyph    g__noDot2l__hamza


// Special bariyeh rules: move any nuqtas within three chars of a bariyeh down.

table(glyph)
cNuqtaLikeLowerNoRing = cNuqtaLikeLower;
cNuqtaLikeLowerNoRing -= (g__attachedRing);

cTakes_lower = (cTakes_nLowerDia, cTakes_hehhookDia);

endtable;

// X+Nl  Y+Nl  Z+Nl  Bariyeh
cTakes_nLowerDia  cNuqtaLikeLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	csMedBy cNuqtaLikeLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+Nl  Y+Nu  Z+Nl  Bariyeh
// Here we attach the upper nuqta too, since if we back up to attach it, it will reattach and mess up
// the second lower nuqta.
cTakes_nLowerDia  cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cMed   cHasUpperMaux    { attach {to = @Y; at = nUpperS; with = nUpperMaux } }
	csMedBy cNuqtaLikeLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+Nl  Y  Z+Nl Bariyeh
cTakes_lower cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLikeLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  cMed=Y DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+Nl(large)  Y  Z  Bariyeh
cTakes_nLowerDia  cNuqtaLowerLarge { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  cMed=Y ^ cNuqtaLikeUpper? DIACS  csMedBy=Z cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+Nl  Y+Nl  Z  Bariyeh
cTakes_lower cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_lower cNuqtaLikeLower { underBy = true; attach {to = @By; at = nByMidLeftLowerS; with = nByLowerM } }
	/ _=B1 _=L1 DIACS  _=B2  _=L2  DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+Nl  Y+Nl  Bariyeh
cTakes_nLowerDia cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByMidRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y  _=Ny DIACS  ^ gBariyehFin=By;

// X+Nl+Nu Y Bariyeh 
cTakes_nLowerDia 
	cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	cNuqtaLikeUpper { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B _=L _=U DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+Nl Y Bariyeh 
cTakes_nLowerDia  cNuqtaLikeLowerNoRing { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	/ _=B _=L  DIACS  ^ csMedBy cNuqtaLikeUpper? cNuqtaLikeSecond? DIACS  gBariyehFin=By;




// Not really needed, because all glyphs with lower diacs can take upper diacs
//table(glyph)
//cTakes_n1Lower_and_nUpperDia = cTakes_n1LowerDia;
//cTakes_n1Lower_and_nUpperDia &= (cTakes_nUpperDia);
//endtable;

// kaf-top, nuqta(s) below
/*
cTakes_kafTopDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	ckafTopDia { attach {to = @K; at = kafTopS; with = kafTopM } }
	/ _=K  _=L  _=T;


cTakes_gafStrokeDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
	/ _=K  _=L  _=S;
*/

// tah above, nuqta(s) below
cTakes_tahUpperDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=L  _=U;
// Do we need this? We shouldn't need to attach a tah to a glyph that doesn't take a tah.
//cTakes_n1LowerDia
//	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
//	ctahUpperDia { attach {to = @B; at = nUpperS; with = tahUpperM } }
//	/ _=B  _=L  _=U;

// nuqtas above, hehhook below
cTakes_hehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above and below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// hamza above, nuqtas below
cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
(cBehIni cBehMed)
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;


// Upper nuqta-like attachment


////gJeemFin  cNuqtaLike { attach {to = @J; at = point(574m, 1274m); with = nUpperM} }
////	/  gJeemMedJm=J  cNuqtaLike?  _=J  _=N;

//cTakes_n1hUpperBehSpecialDia
//	cNuqtaLikeUpper { attach {to = @B; at = n1hUpperBehSpecialS; with = nUpperM } }
//	/ _=B  _=U;

// Put hamza rules first to make sure to use hamza APs for them.
cTakes_hamzaAndHehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=H  _=U;

cTakes_hamzaUpperDia
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=U;

cTakes_hamzaLowerDia
	chamzaLowerDia { attach {to = @B; at = hamzaLowerS; with = hamzaLowerM } }
	/ _=B  _=U;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
// TODO: add real hamzaUpper APs to beh forms.
(cBehIni cBehMed)
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=H;

// Bar after kaf needs to be offset vertically.
/*
(cLamMed cLamFin)
	cbarDia { attach {to = @L; at {x = barS.x; y = barS.y + 380m}; with = barM } }
	/ (cKafIni cKafMed)  MARKS  _=L  _=B;
*/

cTakes_barDia
	cbarDia { attach {to = @B; at = barS; with = barM } }
	/ _=B  _=U;

cTakes_squiggleDia
	csquiggleDia { attach {to = @K; at = squiggleS; with = squiggleM } }
	/ _=K  _=S;

cTakes_digitUpperDia
	cdigitUpperDia { attach {to = @B; at = digitUpperS; with = digitUpperM } }
	/ _=B  g__kafTop_null?  _=U;

////cTakes_gafStrokeDia
////	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
////	/ _=K  _=S;

// Use smallV AP if present, otherwise small-V will attach at nUpper - no longer used.
////cTakes_smallVDia
////	g__smallV { attach {to = @B; at = smallVS; with = nUpperM } }
////	/ _=B  _=U;

// lamValt:
cTakes_smallValtDia
	g__smallV { attach {to = @B; at = smallValtS; with = nUpperM } }
	/ _=B {lamValt == 1}  g__kafTop_null?  _=U;

cTakes_nUpperDia
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U;

cTakes_tahUpperDia
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=U;

// nuqtas above, ring below
cTakes_ringAndNUpperDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U _=R;

cTakes_ringDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	/ _=B  g__kafTop_null?  _=R;

cTakes_grafDia
	cgrafDia { attach {to = @B; at = grafS; with = grafM } }
	/ _=B  g__kafTop_null?  _=GS;

// Odd situation, but just in case:
cIso
	gMaddaAbove { attach {to = @B; at = mUpperS; with = mUpperM } }
	/ _=B  _=M;


// Lower nuqta attachment

// Special case: situation below with small nuqtas
(gBehIniBe gBehMedBe gHehGoalIniBe)
	g__dot1l_small { attach {to = @B1; at = n1LowerS; with = n1LowerM } }
	gBehMedJm
	g__dot1l_small { attach {to = @B2; at = n1LowerS; with = n1LowerM } }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin  cNuqtaLikeLower;

// Special case: beh + beh + jeem - don't use special rule below, but do move center nutqa over a bit.
(gBehIniBe gBehMedBe)
	cDot1l { attach {to = @B1; at = nLowerTightS; with = n1LowerM } }
	gBehMedJm
	cDot1l { attach {to = @B2; at = n1LowerS; with = n1LowerM }; shift.x = 100m }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  /*no diac*/  gJeemFin  cNuqtaLikeLower;

// Special case: beh/yeh + beh/yeh + jeem/tcheh - move center nuqta down to the right of the jeem tail.
(gBehIniBe gBehMedBe gHehGoalIniBe)
	cNuqtaLikeLower { attach {to = @B1; at = nLowerTightS; with = n1LowerM } }
	gBehMedJm
	cNuqtaLikeLower { attach {to = @B2; at = nLowerTightS; with = n1LowerM } }
	/   _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin  cNuqtaLikeLower;

// Special case: lower-nuqta + jeem + beh/yeh + jeem/hah/khah/tcheh - move center nuqta down to the right of the jeem tail.
(gBehIniBe gBehMedBe gHehGoalIniBe gJeemMedBe)
	cNuqtaLikeLower { attach {to = @B1; at = n1LowerS; with = n1LowerM } }
	gBehMedJm
	cNuqtaLikeLower { attach {to = @B2; at = nLowerTightS; with = n1LowerM } }
	/   cNuqtaLikeLower  _=B1  _=N1  cDiacritic?  _=B2  _=N2  cDiacritic?  gJeemFin;

// Special case: yeh + beh + hah/khah - the nuqtas get tangled due to collision and the possibility of
// the lower nuqtas moving down by the jeem tail, which turns off the sequence mechanism.
(gBehIniBe gBehIniBe_jmF gBehMedBe) cNuqtaLower { attach {to = @B1; at = n1LowerS; with = n1LowerM }; shift {x = -100m; y = 50m} }
	(gBehMedJm gBehMedJmR)  cNuqtaLower { attach {to = @B2; at = n1LowerS; with = n1LowerM }; shift {x=50m; y = -230m} }
	/ _=B1  _=N1  _=B2  _=N2  gJeemFin;

cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_tahLowerDia
	ctahLowerDia { attach {to = @B; at = tahLowerS; with = tahLowerM } }
	/ _=B  _=U;

// Special case: heh-hook plus final ain
cTakes_hehhookDia  
	g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM };
		shift {x = 130m; y = 140m} }
	/ _=B  _=H  cAinFin;

// Heh-hook
cTakes_hehhookDia  g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM } }
	/ _=B  _=H;

// Hehhook - big
////////attachR_BN(	gHehGoalIni,	g__hehHook_big,		default2,		default2_)


// TEMPORARY - fall-back attachment
// Needed to test in Graphite1.
//cIniMedFin  g__kafTop_null;

cIniMedFin  cNuqtaLike { attach {to = @1; at = zeroS; with = zeroM } };


// Subtending marks

// NB: at this point digits should be in visual order, right to left,
// so we attach the left-most (logically first) to the sign, and proceed to the right.

cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign4=S;

cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign3=S;

cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign2=S;

cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign1=S;

// However, there is a bug in some implementations (eg Firefox) where the numbers are still in
// logical order.

cSign4=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true};
	
cSign3=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true};
	
cSign2=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true};
	
cSign1=S
	cSignDigit { attach {to=@S;  at=digitS; with=digitM }; insert = true};

endpass;  // 2 (9)

endtable;  // pos


// Define fake right and left bounding boundaries that will be compared to the side-bearing marks
// and used to determine the ideal margin/kerning.

table(glyph) {AttributeOverride = 0}

// Define for all needed glyphs where they have not been defined in the font.
cIni {kernBbRightS = point(0m,0m) };
cFin {kernBbLeftS = point(0m,0m) };
cIso {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
cKernPunct {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

cQuote = (g_quoteleft g_quoteright g_quoteleftArab g_quoterightArab
	g_quotedblleft g_quotedblright g_quotedblleftArab g_quotedblrightArab
	g_quotedbl g_quotedblArab);

cQuoteArab = (g_quoteleftArab g_quoterightArab g_quotedblleftArab g_quotedblrightArab g_quotedblArab);
cQuoteRightArab = (g_quoterightArab g_quotedblrightArab);
cQuoteLeftArab = (g_quoteleftArab g_quotedblleftArab);

cFullStop = (gFullStop gFullStopDot);

endtable;


table(glyph) {AttributeOverride = 1}

cPostKernable = (cIso, cIni, cKernPunct) {
	dbgBbRight = bb.right; dbgRsb = rsb; dbgAdv = advancewidth;
	kernRsb = advancewidth - ((kernBbRightS.x == 0) ? bb.right : kernBbRightS.x);
////	dbgNaturalRsb = advancewidth - bb.right;
};

cPostKernableNoPunct = cPostKernable;  
cPostKernableNoPunct -= (cKernPunct);

// Kludge because Graphite seems to have a problem figuring these out - nope, now seems to be working ok:
///////g_ellipsisArab { kernBbRightS = point(1822m, 0m); kernRsb = aw - kernBbRightS.x };


cKernable = (cIso, cFin, cKernPunct) {
	dbgBbLeft = bb.left; dbgLsb = lsb;
	kernLsb = ((kernBbLeftS.x == 0) ? bb.left : kernBbLeftS.x);
}

c_jumpTail = ( cJeemFin, gAinFin );


cls_excludingGlyphs = (cKafMed csKafMed_base) {
	collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

cls_excludingGlyphs_kern = (cKafFin) {
	collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

endtable;  // glyph


// Nuqta collision fixing

table(positioning)

if (collFix > 0)

pass(3)  // 10

// Set up for collision fixing

#define MAXKERN 5000m
#define MINKERN -700m
//#define MINKERN_TIGHT -3000m -- not used
//#define MINKERN_WIDE -200m   -- not used
#define STDMARGIN 150m
#define STDMARGINWT 400
#define STDMARGIN_N1 150m
#define STDMARGINWT_N1 200
#define STDMARGIN_N2 150m
#define STDMARGINWT_N2 200
#define STDMARGIN_DIAC 200m
#define STDMARGINWT_DIAC 400
#define STDMARGIN_DIGIT 250m

//#define KERNMARGIN_TIGHT 150m  -- not used
//#define KERNMARGIN_MED 300m
//#define KERNMARGIN_WIDE 400m

#define KAFOVERHANG -800m


#define ORDER_UNUQTAS 1
#define ORDER_LNUQTAS 2
#define ORDER_LNUQTAS_SUB_BYEH 3

#define ORDER_UDIACS 4
#define ORDER_LDIACS 5

table(glyph) {AttributeOverride = 1}

cNuqtaLikeUpper {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_UNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 50 };
		valign { height = 275m;	weight = 500 }
	}
};

csNuqta_small { sequence.valign.height = 250m };

gHighHamza { sequence.class = 0 };

cNuqtaLikeLower {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_LNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 500 }; // weight was 50
		valign { height = 275m;	weight = 500 }
	}
};

g__hehHook_small { sequences.class = 0 };

g__bar { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };
g__attachedRing { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };

cgafStrokeDia { collision { margin = 0; flags = 0 }; sequence { class = 0; order = 0 } };


// Smaller nuqta glyphs need larger margins:
cNuqta { collision {margin = STDMARGIN;    marginweight = STDMARGINWT_N2} };
cDot1u { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
cDot1l { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
cDot2u { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };
cDot2l { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };


cDiacriticUpper {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; } - set in the rule
};

gNoonGhunnaMark { collision.margin = 300m; marginweight = 300 }; // override

cDiacriticLower {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; } - set in the rule
};

//cNuqtaLikeAbove { collision.order { class = ORDER_UNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };
//cNuqtaLikeBelow { collision.order { class = ORDER_LNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };

endtable; // glyph

// Special cases where collision avoidance SHOULD fix the problem but doesn't. Do it by hand.
g__dot1u { shift.y = -150m; collision.flags = COLL_FREEZE }
	/ gLamIniFe MARKS  gFehMed _=N  cKafMed;
cNuqtaLikeUpper {shift {x = -150m; y = 130m}; collision.flags = COLL_FREEZE}  cNuqtaLikeUpper {shift.x = 150m}
	/ gJeemMedBeM1  _=N1  gBehMedBe  cNuqtaLikeLower? _=N2;
(g__dot2u g__dot3u) {collision.flags = COLL_FREEZE} / (gDalFin gKafFin) _=N ;

// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags); collision.flags = SET_IGNORE(collision.flags) };

c_zerojoin   { collision.flags = SET_IGNORE(collision.flags) };
c_zeronojoin { collision.flags = SET_IGNORE(collision.flags) };
//g_zeroWidthNoBreakSpaceShowInv  { collision.flags = SET_IGNORE(collision.flags) };

// Don't move nuqtas to adjust for punctuation; instead kern the punctuation.
cKernPunct { collision.flags = SET_IGNORE(collision.flags) };


g__kafTop_null { collision.flags = SET_IGNORE(collision.flags) }  /  cBase  _ ;   // make context long enough to give precedence
g__kafTop_null { collision.flags = COLL_FREEZE }  /  cBase  _ ;

// Upper nuqtas

// Gaf strokes are considered part of the base - they don't move.
cgafStrokeDia { collision.flags = COLL_FREEZE }  /  cBase  _ ;     // make context long enough to give precedence
g__grafStroke { collision.flags = COLL_FREEZE }  /  cBase  g__kafTop_null?  _ ;

// Things on top of alefs should never move horizontally. For now, just don't let them move at all.
// Also, don't force preceding nuqta-like things to move above them.
cNuqtaLikeUpper { collision.flags = COLL_FREEZE; sequence.class = 0 }  /  (gAlef cAlefFin)  _;


// Small V over lam needs to stay nicely centered.
g__smallV { collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 50m;
		min.y = -300m;
		max.y = 300m;
	};
	sequence.class = 0  // eg, \u0646\u0650\u06A9\u06B5
  }  /  (cLamIM cLamFin)  _;

	
// Special case: if there is a nuqta before a zah, scootch the nuqta of the
// zah down pretty close to the base.
/**
cNuqtaLikeUpper { 
	shift { x = 50m; y = -150m }; // note that shifting in RTL moves forward, ie, left.
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 100m;
		min.y = -100m;
		max.y = 300m;
	}
} /  cNuqtaLikeUpper=N1 DIACS  cTahMed  _=N2 ;
**/


// The nuqta on the zah (tah form) fits nicely above it, so it is not normally helpful to move it.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't let this one move left much
	max.x = 100m;
	min.y = -200m;  // shouldn't need to move vertically either, at least by much
	max.y = 300m;
} } / cTahMed _ ;

// Special case: fah/qaf + jeem(wide) + kaf: don't let feh nuqtas move above kaf stroke
cNuqtaUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't it move left much
	max.x = 150m;
	min.y = -300m;
	max.y = 0m;
} } / cFehIM _=N  cDiacritic?  gJeemMedKf_wide;


// Special case: khah + teh/theh + kaf/lam/alef
// Not essential but it does look a little better.
// If we decide to use this, we still need to turn on collision.fix.
//////cNuqtaLikeUpper { shift { x=-100m; y = -150m } }  /  gJeemMedBeKl  cNuqtaLikeUpper  cDiacritic?  gBehMed  _=N;

// Special case: hah + teh + alef/lam
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 300m; // don't let it pop up to the top of the alef/lam
} } / (cJeemIM) cNuqtaLikeLower?  cDiacritic?  gBehMed  _ cDiacritic?  (cAlefFin cLamFin cLamMed);
*/

// Exception to special case below when there is a previous lam/kaf.
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 400m;
} } / (cLamIM cKafIM) cDiacritic?  cBase  _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);
*/

// Special case involving jeem + noon/teh/sheen - don't allow nuqta to move right
/* NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 100m;  // less than normal
	min.y = -300m;
	max.y = 400m;
} } / cJeemIM  cNuqtaLike?  cDiacritic?  (cBehMed cSeenMed)  _  ;
*/

// Special case: beh/yeh + kaf/lam + heh-doachashmee - move nuqtas down and to the right
cNuqtaLikeLower {
	shift { x = -75m; y = -75m };
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 350m;
		min.y = -500m;
		max.y = 300m;
	}
}  /  (gBehIni gBehMed)  _=N  cDiacritic?  (gKafMedHd gGafMedHd gLamMedHd) g__kafTop_null?  cDiacritic?  
			(cHehDoMed cHehDoFin);

// Special cases involving kaf tops - allow nuqtas to move further right than normal.
// Remove for now - this is too extreme.
/***
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 800m; // a lot more than normal
	min.y = -300m;
	max.y = 400m;
} } / _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);
***/

// Special case: khah + teh/theh + alef/lam - move teh/theh nuqtas above alef/lam - no, we're not doing this
/***
cNuqtaLikeUpper { shift { x = -80m; y = -180m } }
	(cDot2u  cDot3u  gHamzaAbove) { 
		shift { x = 50m; y = 800m; };
		collision {
			flags = SET_FIX(collision.flags);
			min.x = -250m;
			max.x = 200m;
			min.y = -300m;
			max.y = 300m;
		};
		sequence.class = 0;
	}
	/ cJeemIM  _=N1  cDiacritic?  cBehMed  _=N2  cDiacritic?  (gAlefFin  cLamMed  gLamFin);
***/	


// Special case: khah + teh/theh - allow more movement to get the nuqta on the jeem to the right of the nuqta on the beh form.
/*** NOT NEEDED
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m;  // standard is 200m
	min.y = -300m;
	max.y = 400m;
} } / cJeemIM _ cDiacritic? cBehMed cNuqtaLikeUpper;
**/

// Special case: beh + jeh + beh; the small-nuqta version is problematic.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = 250m;  // don't let nuqta jump above beh
	max.x = 200m;
	min.y = -300m;
	max.y = 400m;
} } /  gBehMedRe MARKS  cRehFin  _  cDiacritic?  cBehIso;


// Special case: nuqta-small-V + kaf/gaf
g__dot1u_smallVKf {
	shift { x = -130m; y = -230m };
	collision {
		margin = 80m;
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 350m;  // standard is 200m
		min.y = -300m;
		max.y = 400m;
	};
	sequence.class = 0;
} /  cIni  _  (cKafMed cKafFin);

// Special case: jeem + noon/teh/theh + reh
cNuqtaLikeUpper {
	shift { x = 150m; y = 150m };
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 200m;
		min.y = -300m;
		max.y = 400m;
		margin = 250m;  // standard is 150m
	} }
	/  gJeemIniBeRe MARKS  gBehMedRe _=N;

// Special case: beh + lam + jeem
cNuqtaLikeLower {
	shift { x = -150m; y = 80m };
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 200m;
		min.y = -300m;
		max.y = 400m;
		margin = 250m;  // standard is 150m
	} }
	/  gBehMed _=N DIACS (gKafMedCh gGafMedCh gLamMedCh);

// Special case: teh/theh + heh-goal + hamza
// Nuqtas on finals can be moved quite a bit to the left.
gHamzaAbove { 
	shift { x = 370m; y = -300m };
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -500m;   // more than normal (-250)
		max.x = 200m;
		min.y = -300m;
		max.y = 400m;
	} }
	/  gBehMedHgF  cNuqtaLikeUpper  gHehGoalFin _;

// Use a different sequencing class for low-tooth nuqtas.
table(glyph)
cLowNuqta = (gBehMedAi, gBehIniBeM1, gBehMedBeM1, gBehMedFe, gBehMedSd, gBehMedTa, gBehIniBeNn, gSeenIniBeM1, gSeenMedBeM1, gSeenIniBeNn, gSeenMedBeNn);  // gBehMedAi??
endtable;

cNuqtaLikeUpper {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 200m;
		min.y = -300m;
		max.y = 400m;
	};
	sequence.class = 5;
}  /  cLowNuqta  _=N;

// Special case: flat glyph + nuqta + lam/kaf + base+nuqta
// Normally the second nuqta would push the first one up, but the lam/kaf breaks the sequencing.
// (In theory this COULD be a problem if the nuqta before the lam/kaf needs sequencing with a
// previous glyph, but hard to imagine...)
cNuqtaUpper { collision {
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 350m; // more than normal (200)
		min.y = -300m;
		max.y = 400m;
	};
	sequence.class = 0;
}	/  (gBehIni gBehMed gSeenIni gSadIni)  _=N  cDiacritic?  (cKafMed  cLamMed) MARKS  (cMed cFin) cNuqtaUpper;

// Special case: noon + hah-3dots - the nuqtas fit together too tightly
cNuqtaLikeUpper { shift.x = -100m;
		collision {
			flags = SET_FIX(collision.flags);
			margin = 300m;  // more than normal
			min.x = -250m;
			max.x = 200m;
			min.y = -300m;
			max.y = 400m
		} }
	cNuqtaLikeUpper { collision {
			flags = SET_FIX(collision.flags);
			margin = 300m;  // more than normal
			min.x = -250m;
			max.x = 200m;
			min.y = -300m;
			max.y = 400m;
		} }
/ gBehIniJm  _=N1  cDiacritic?  gJeemFin  _=N2;

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m; // more than normal (200)
	min.y = -300m;
	max.y = 400m;
} } / cIni cNuqtaLikeLower? _;

table(glyph)
cNarrowTop = (cFehIM gFehFin cLamIM gLamFin);
cFinNotNarrow = cFin;
cFinNotNarrow -= (gFehFin gLamFin);
endtable;

// Nuqtas on finals can be moved quite a bit to the left.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;   // more than normal (-250)
	max.x = 200m;
	min.y = -300m;
	max.y = 400m;   // was 1000, that's too much
} } /  cFinNotNarrow _;

/*** Special case: jeem followed by nuqta
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	margin = 250m;
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 400m;
} }  /  cJeemIni  cNuqtaLike?  cBase  _; 
***/

// Never shift the graf stroke.
g__grafStroke { collision.flags = COLL_FREEZE }  /  cBase  g__kafTop_null?  _ ;  // add context to increase precedence, just in case

// Above narrow glyphs with obvious centers, nuqtas shouldn't move far left or right.
// WHAT ELSE SHOULD GO IN HERE????  Ain?
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -80m;
	max.x = 80m;
	min.y = -300m;
	max.y = 400m;  // was 1000, that's too much
} }  /  cNarrowTop  _;

// Default case: nuqtas above (other than initial) can move more to the left than the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 400m; // was 1000, that's too much
} };


// Middle nuqta-like stuff: bars and rings
// Ideally it would be nice to be able to move the bars up and down a little to avoid
// collisions, but to do that we would need to be able to ignore the base (lam) from
// the perspective of the bar.

g__bar { collision.flags = COLL_FREEZE }    /  cBase  _ ;  // add context to increase precedence
g__attachedRing { collision.flags = COLL_FREEZE }  /  cBase  _ ;

// Lower nuqtas

// Nuqtas before certain finals can move down quite a bit to jump below swashes.
// Note that if we make the lower limit too low, the nuqtas will jump completely *below* 
// the swash, which is not what we want. We want it to be down and to the right.
cNuqtaLikeLower_jump {
	//shift.y = -800m; // do we want this?
	//shift.x = 200m; // since we are not using the sequence attrs, avoid it moving down and to the left of another nuqta
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 700m;    // a lot!
		min.y = -1600m;  // a lot!
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / _  c_jumpTail;

// Gueh vertical dots must stay close to the kaf stem.
cDot2vl {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -100m;
		max.x = 150m;
		min.y = -500m;
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / cKafIM  g__kafTop_null  _=N;


// Nuqtas below a bariyeh cannot move up, shouldn't need to move down, and they don't flow diagonally.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -400m;
		max.x = 400m;
		min.y = -20m;
		max.y = 0m;
  };
  sequence { class = 0; order = 0 }
} / cIni?  _ {underBy == true};


// If there's a remote chance that the heh-hook will collide with a bariyeh, let it move down a lot.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 400m;
	min.y = -1000m;  // nuqtas use 1000m
	max.y = 50m;
} }  /  _=H  cDiacritic? cMed MARKS  [cMed MARKS]? cBariyehFin;


// Heh-hooks need to be kept centered under the base. But because they are originally positioned quite a bit to the left
// they can move right a lot. 400 lets it move to the right side of the heh-goal, and avoid a following jeem or ain.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 400m;
	min.y = -100m;  // nuqtas use 1000m
	max.y = 50m;
} }  /  cIniMed  _; // enough context to give it precedence

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 400m;  // 600 breaks \u067E\u0650\u06CC\u064F\u0648
	min.y = -500m;
	max.y = 300m;
} }  /  cIni  _;

// Default case: nuqtas below (other than initial) can move more to the right than the left.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 350m;   // making this 400 helps \u067E\u0650\u06CC\u0686\u06BE\u06D2 but breaks other things
	min.y = -500m;
	max.y = 300m;
} };

// Exclusion glyphs for space above kafs and gafs

// For ngoeh or kaf w/ 3 dots, don't using the exclusion glyph - 
// the nuqtas need to go right on top of the gaf.
//(cls_excludingGlyphs cls_excludingGlyphs_kern)
cKafIM { collision {
			flags = CLEAR_FIX(collision.flags);
			flags = CLEAR_KERN(collision.flags);
	} }
	(cDot2u cDot3u) { collision {
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 200m;
		min.y = -100m;
		max.y = 400m;   // was 1000, that's too high
		// ;  shift { x = 200m; y = -100m }
	} }
	/ ANY  _=K  g__kafTop_null? _=N; // the ANY increases the precedence


// There is a bug in the Graphite engine that mis-initializes the exclusion glyph that causes bugs in the
// collision fixing.
// For now, until this gets fixed, just set the exclusion glyph if a neighboring glyph has an upper nuqta.
// Eventually, remove the context for the next two rules and merge them.
cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  _=EG;

cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  _=EG  g__kafTop_null?  cDiacritic?  cBase  cNuqtaLower? cNuqtaUpper;

cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  _=EG;


// Special case: teh/theh + jeem + kaf
// Include the exclusion glyph for this case as well, to avoid nuqtas on the jeem jumping up.
// - no longer needed since we are using gJeemMedKf_wide
/***
cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} }  /  cNuqtaLikeUpper  cDiacritic?  cJeemMed  MARKS  _=EG;
***/

// Don't kern glyphs before the high hamza; retain the space.
// Move kerning special cases down to pass 10.
////cKernable  (gHighHamza gHighHamzaArabic);

// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
// We actually set the kerning parameters in the final pass. But here, at least indicate
// which glyphs can be kerned, which affects how shifting works around them.

cKernable { collision {
	//---flags = SET_FIX(collision.flags); -- move actual kerning to end of process
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	////max.x = 300m; min.x = 0;  // kerning right is logically equivalent to shifting left in RTL
	//---max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


// Other bases are not moved.
cIniMed { collision { flags = COLL_FREEZE } };

cDiacritic { collision.flags = SET_IGNORE(collision.flags) };	// these have not been attached, so don't bother with them

cQuoteArab { collision.flags = SET_IGNORE(collision.flags) }; // fix with kerning

endpass;  // 3 (10)

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.
if (collFix > 1)
pass(4) { CollisionFix = 5 }  // 11

// Perform base + nuqta collision fixing. Any failures leave for now.

endpass;  // 4 (11)
endif;

endtable; // positioning


/*****  Not needed - the collision-fix pass sets all the positions accurately.
table(glyph)
cNonBaseTemp = (cNuqtaLike  g__kafTop_null)
endtable;

#define NOTSET 12345  // some number that is not likely to be a real value

c_initial {user7 = position.y}  c_final {user7 = position.y}   / _=I  MARKS2N  _=F;
c_initial {user7 = position.y}  c_medial {user7 = position.y}  c_final {user7 = position.y} / _=I MARKS2N  _=M MARKS2N _=F;

c_medial {user7 = NOTSET}  c_medial {user6 = position.y}   c_final {user7 = NOTSET}
	/ ^ cIniMed cNonBaseTemp?  _=M1  cNonBaseTemp?  _=M2 cNonBaseTemp?  _=F {user7==0};

c_medial {user7 = NOTSET}  c_medial {user7 = position.y}
	/ ^ cIniMed MARKS2N  _=M1 MARKS2N  _=M2 {user7 == NOTSET};

c_initial {user7 = position.y}  c_medial {user7 = position.y}  /  _=I  MARKS2N  _=M {user7==NOTSET} ;

// Do this last:
c_final {user7 = position.y}  /  _ {user7 == NOTSET};
*****/


#define pairKern user2
#define tooHigh user3
#define reattached user4

// currently not used
////#define marginSet user9  -- currently not used


table(positioning)

//
//	KAF HEIGHT ADJUSTMENTS
//

table(glyph)

cNuqtaLikeUpperNoKT = (cNuqtaLikeUpper);
cNuqtaLikeUpperNoKT -= (cKafTop);

c_narrow = (gBehMed gMeemMed gAinMed);

endtable;

// Since the last positioning pass does not block the area above the kaf, limit the movement
// of nuqta behind/under a kaf.
#define STAYBELOWKAF {collision {min.x = 0m; max.y = 300m}}

// height at which to invoke various short forms
#define SHORTERKAF_HT	1900m  // height at which we need a shorter kaf
#define SHORTKAF_HT  	1350m  // height at which we need a short kaf
#define PUSHDOWN			3280m  // height at which to push down marks
#define PUSHUP			-630m  // lower position at which to push up marks
#define SHORTFINAL2		2700m
#define SHORTFINAL1		3050m
#define SHORTFINAL0		3650m
#define SHORTFINAL_KAF	1600m


pass(5)  // 12

// Kaf-top collision fixing/prevention and tall sequences

// This pass marks glyphs appropriate as needing fixing.

// Special case: alef-madda + kaf/gaf + final-heh-goal/beh/tah/feh - make kaf tall so alef-madda can squeeze in
csKafIni_medium  g__kafTop_null
	>  csKafIni_base$K  csKafIni_top_taller$K
	/  gAlefMaddaAbove  _=K  _=T  MARKS (gHehGoalFin gBehFin_bfkl gTahFin gFehFin cDalFin);

// Very high kaf + large-nuqta - don't make taller, it's already too high
cNuqtaUpperLarge  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @K {tooHigh = 1}  @T
	/  _=N _=K {position.y > SHORTERKAF_HT}  _=T;

// Tall: large-nuqta + diacritic + kaf
cNuqtaUpperLarge  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N  cDiacritic  _=K ^ _=T;

// Keep medium: large-nuqta + kaf
cNuqtaUpperLarge  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  @K  @T
	/  _=N  cDiacritic?  _=K ^ _=T;

// Special case: Lam + diac + kaf - shorten lam AND heighten kaf
(gLamIni gLamMed) csKafMed_medium  g__kafTop_null  
	>  cLam_short  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=L  (cDiacritic g__smallV g__smallTah)  cDiacritic?   _=K  _=T;

// Don't change kaf, rather shorten lam:
// \u0645\u0644\u06AF\u064E\u06CC
(gLamIni gLamMed)  (cKafMed cKafFin)  >  cLam_short  @K
	/  _=L cDiacritic?  _=K  g__kafTop_null?;  // include the extra slot for precedence

// Tall: after gGafMedKf_lm - lam + gaf + kaf combination
csKafMed_medium  g__kafTop_null  
	>  csKafMed_baseT$K  csKafMed_top_tall$K
	/  gGafMedKf_lm  g__kafTop_null cDiacritic?  _=K  _=T;

// Tall: lam/tah + kaf
// TODO: move cBaseTall back into context
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B1  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=B1  MARKS  _=K  _=T;

// Tall: short-lam + kaf + ring (short-lams are ALMOST short enough to fit under kaf-rings, but not quite)
cLam_short  csKafMed_medium  g__kafTop_null
	>  @L  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=L  MARKS  _=K  _=T  g__attachedRingMid;

// Tall: tall kaf + kaf/gaf (note: does not apply to gaf + kaf)
csKafMed_medium  g__kafTop_null
	>  csKafMed_baseT$K2  csKafMed_top_tall$K2
	/  csKafIM_base g__kafMedTop_tall  MARKS  _=K2  _=T2;

cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N cBaseTall  MARKS  _=K  _=T;

// Tall: nuqta + diac + kaf
cNuqtaLike  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N  cDiacriticUpper  cDiacriticUpper?  _=K  _=T;

// Tall: nuqta-smallV + kaf, nuqta-smallTah + kaf
(csNuqtaPlusMark csNuqtaPlusMarkKf)  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N  cDiacriticUpper?  _=K  _=T;

// Exception to rule below, because there is no 'taller' form for pre-meem:
cDiacriticUpper  gKafIniMm  g__kafTop_null  
	>  @D STAYBELOWKAF  @K  @T
	/  (gAlef cAlefFin)  _=D  _=K {position.y < 1100m} _=T;
// Exception to rule below, because final bariyeh adds horizontal space:
cDiacriticUpper  >  @D
	/  (gAlef cAlefFin)  _=D  ^ csKafIni_medium {position.y < 1100m} g__kafTop_null  MARKS  cMed  MARKS  gBariyehFin;

// Tall: alef + diac + kaf
// (Note that the kaf+bariyeh makes no change.)
cDiacriticUpper  csKafIni_medium  g__kafTop_null  
	>  @D STAYBELOWKAF  csKafIni_base$K  csKafIni_top_taller$K
	/  (gAlef cAlefFin)  _=D  _=K {position.y < 1100m} _=T;

// Special case: exception to rule below when form before kaf is a jeem (eg, \u0641\u062E\u06AF\u0633):
cDot1u  cDot1u  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N1  cDiacritic?  cJeemMed  _=N2  cDiacritic? ^ _=K  _=T;

// Don't change: single-nuqta + single-nuqta + kaf (eg, \u0628\u0650\u0646\u0650\u0646\u06AF\u064E\u06A9\u06C1)
cDot1u  cDot1u  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  @K  @T
	/  _=N1  cDiacritic?  cMed ^ _=N2  cDiacritic? _=K  _=T;

// Tall: nuqta + nuqta + kaf (eg, sheen + teh + kaf)
cNuqtaLikeUpperNoKT  cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=N1  cDiacritic?  cMed  _=N2  cDiacritic?  _=K  _=T;

// nuqta + diac + kaf => default
csKafMed_medium  g__kafTop_null  >  @K  @T
	/  cNuqtaUpperSmall  cDiacritic  _=K  _=T;

// Short + medium-short: gaf + ??? + kaf/gaf
csGafIM_medium g__kafTop_null  cNuqtaLikeUpper  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  
			@Nfb STAYBELOWKAF // keep nuqta from hopping above kaf
			csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) _=Nfb cDiacritic? _=K _=Tk;

csGafIM_medium g__kafTop_null  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) cNuqtaLike? cDiacritic? _=K _=Tk;

// Maybe not needed, but it does help avoid the kafs touching.
csKafIM_medium g__kafTop_null  csKafMed_medium_noGaf g__kafTop_null
	>  csKafIM_base$G  csKafIM_top_shorter$G  csKafMed_baseT_noGaf$K  csKafMed_top_tall_noGaf$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) cNuqtaLike? cDiacritic? _=K _=Tk;

// Gaf + kaf/gaf-medial => shorter
csGafIM_medium g__kafTop_null  csKafMed_medium  g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_baseT$K  csKafMed_top_tall$K
	/  _=G _=Tg  cNuqtaLike?  cDiacritic?  _=K _=Tk;
// same as above but with a short gaf - still needs a tall following kaf
csKafMed_medium  g__kafTop_null
	>  csKafMed_baseT$K  csKafMed_top_tall$K
	/  gKafMedDk_base g__gafMedTop_short  cNuqtaLike?  cDiacritic?  _=K _=Tk;

// Lam + gaf + kaf/gaf => special form of gaf
gGafMedDk  >  gGafMedKf_lm
	/  cLam_short MARKS  _=G  g__kafTop_null  cNuqtaLike? cDiacritic?  cKafMF g__kafTop_null?;

// Gaf + kaf/gaf-final => short
csGafIM_medium  g__kafTop_null  cKafFin
	>  csGafIM_base$G  csGafIM_top_short$G  @K
	/  _=G _=Tg  cNuqtaLike? cDiacritic? _=K;

// Medium-short: lam/tah + jeem/meem + kaf - do we need this with the wider jeem?
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B  csKafMed_baseT$K  csKafMed_top_medshort$K
	/  _=B  cNuqtaLike? cDiacritic?  (/*cJeemMed*/ cMeemMed)  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Medium-short: tah + beh/meem/ain + kaf...
cTahIM  csKafMed_medium  g__kafTop_null  
	>  @Ta  csKafMed_baseT$K  csKafMed_top_medshort$K
	/  _=Ta cNuqtaLike? cDiacritic?  c_narrow cNuqtaLike? cDiacritic?  _=K  _=T;

// Medium-short: nuqta + jeem + kaf...
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N {shift.x = -300m; collision {max.x = 600m; max.y = 200m}}   // move right, not up
			csKafMed_baseT$K  csKafMed_top_medshort$K
	/  _=N  cDiacritic?  cJeemMed_stdwidth  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Short round form: tah + kaf + lam/alef - not needed
////cTahIM  csKafRound_medium  g__kafTop_null
////	>  @Ta  csKafRound_short  @Null
////	/  _=Ta MARKS  _=K MARKS  _=Null;

// No change (\u062C\u0646\u06AF\u06CC)
cDot1u  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  @K  @T
	/  cJeemIM  cNuqtaLike?  cDiacritic?  cMed  _=N  cDiacritic?  _=K  _=T;

// Tall (\u062E\u064F\u0634\u06A9\u06CC)
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  csKafMed_baseT$K  csKafMed_top_tall$K
	/  cJeemIM  cNuqtaLike?  cDiacritic?  cMed  _=N  cDiacritic?  _=K  _=T;

// No change: never make shorter after a kaf/gaf.
cNuqtaLikeUpperNoKT?  cKafMed  g__kafTop_null
	>	@N  @K  @T
	/  cKafTop  _=N  cDiacritic?  _=K  _=T;

// No change: don't make shorter after a narrow substantial base with nuqta or diac
(cNuqtaLikeUpperNoKT cDiacritic)  cKafMed  g__kafTop_null
	>	@N STAYBELOWKAF  @K  @T
	/  (cFehIM cAinIM cJeemIM) _=N  _=K  _=T;

// Preclude rule below that shortens the second kaf; don't want that after another kaf.
cNuqtaLikeUpperNoKT?  csKafIM_medium  g__kafTop_null
	>	@N  STAYBELOWKAF  @K  @T
	/  cKafTopAltHt  _=N  cDiacritic?  ^  _=K  _=T;

// Situations where short kaf is needed due to height (except cases above where we know it's not appropriate)

// Notice that we never substitute a shorter kaf for gKafMedJm_lowentry, because it is used when we need extra 
// vertical space.

cNuqtaLikeUpperNoKT?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  csKafIM_base$K  csKafIM_top_shorter$K
	/  _=N  cDiacritic?  _=K {position.y > SHORTERKAF_HT && (shortForms == 1 || shortForms == 3)}  _=T;

cNuqtaLikeUpperNoKT?  cDiacritic?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @D  csKafIM_base$K /**{user6 = bb.top; user7 = position.y + bb.top}**/  csKafIM_top_short$K
	/  _=N  _=D  ^  _=K {position.y > SHORTKAF_HT && (shortForms == 1 || shortForms == 3)}  _=T;


// Don't shift down, because previous glyph is higher anyway.
cNuqtaLikeUpperNoKT  /  (cLamIM cKafIM cTahIM) MARKS  cMed _ { position.y > PUSHDOWN };

// Like rule below, but don't move ngoeh nuqtas down so far, because (a) they are already pushed down a bit,
// (b) they don't always get collision-fixed, and (c) the diagonal stroke of the gaf sticks up anyway.
cNuqtaLikeUpperNoKT { shift.y -= 100m; collision.margin -= 50m } / cKafNoIso cKafTop  _ { position.y > PUSHDOWN };
// If a nuqta is up above the line, move it down and let the collision fixing algorithm pop it
// back up if necessary.
#if (WEIGHT >= WT_BOLD)
cNuqtaLikeUpperNoKT { shift.y = -100m  /* ; collision.margin -= 50m */ } / _ { position.y > PUSHDOWN };
#else
cNuqtaLikeUpperNoKT { shift.y = -200m  /* ; collision.margin -= 50m */ } / _ { position.y > PUSHDOWN };
#endif
// Similarly for tall nuqtas below the line, if they also have a diacritic under them.
cNuqtaLikeLowerTall { shift.y = 100m; collision.flags = CLEAR_FIX(collision.flags) }
	/ _ { position.y < PUSHUP } cNuqtaLikeUpper? cDiacriticLower;


// If a nuqta is not near a height-adjusted kaf, turn off collision fixing for next time around.
// Note that this also turns it off for g__kafTop_null, which is fine (although it should already be off).
cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };


// Debugging:
//cIni {user6 = position.y; user7 = position.y + bb.bottom; user8 = position.y + bb.top};

endpass;  // 5 (12)


table(glyph)
csFinal_regular = (gSeenFin, gSadFin, gJeemFin, gAinFin, gChotiyehFin, gChotiyehFin_bfkl,
	gNoonFin, gQafFin, gQafFin_stfh, gLamFin, gMeemFin);
csFinal_short = (gSeenFin_short, gSadFin_short, gJeemFin_short, gAinFin_short, gChotiyehFin_short, gChotiyehFin_bfkl_short,
  gNoonFin_short, gQafFin_short, gQafFin_stfh_short, gLamFin_short, gMeemFin_short);

csMed_regular = (gJeemMedBy, gBehMedQf);
csMed_short = (gJeemMedBy_short, gBehMedQf_short);
endtable;


if (shortForms > 1)
pass(6)  // 13

// This is left over from pass 5(12). Sequences of kafs get complicated so it helps to
// clean up in a separate pass.
// Never follow a standard medium kaf with a short one. We're essentially undoing a rule triggered above.
csKafMed_base_noGaf  g__kafMedTop_short  >  csKafMed_medium_noGaf   g__kafTop_null
	/  (gKafMedDk  gGafMedDk)  g__kafTop_null  MARKS  _=B  _=T;
csKafMed_base_noGaf  g__gafMedTop_short  >  @B   g__gafMedTop_tall
	/  (gKafMedDk  gGafMedDk)  g__kafTop_null  MARKS  _=B  _=T;
csKafMed_base_noGaf  g__kafMedTop_short  >  @B   g__kafMedTop_tall
	/  gKafMedDk_base  g__kafMedTop_tall   MARKS  _=B  _=T;


// This pass does the adjustments for tall words, including shifting nuqtas/marks down and 
// substituting alternate height kafs.

// Special case: \u0628\u0631\u0627\u0646\u06AF\u06CC\u062E\u062A\u06AF\u06CC
// Note that this is quite a rare word, and it is questionable how generally useful
// these rules are for other contexts.
// Consider whether we want to get rid of these rules.
gBehIni {shift.y = -150m}  gKafMedBe_base {tooHigh = 1; shift.y = -50m}  cKafTop {shift.y = -150m} 
	/ _=B  MARKS  ^ _=K {position.y > 2800m} _=T;

gJeemMedBeKl  {shift { x = 105m; y = -130m } } gBehMed {tooHigh = 1}
	/  _=J {tooHigh == 1} cNuqtaUpper  ^  _=B  cNuqtaUpper  csKafMed_base;

(gKafMedCh gGafMedCh gKafMedCh_base)  gChotiyehFin_bfkl
	>	@K { shift { x = 140m; y = -220m } }  gChotiyehFin_bfkl_short
	/	_=K {tooHigh == 1} cKafTop  MARKS  _=C;


// This sequence is tall:
g_seqKhahMeemJeem  cMed  >  @KMJ  @M {tooHigh = 1}  /  _=KMJ ^ _=M;

// high initial with both nuqta and diacritic:
cIni     cMed  >  @I  @M {tooHigh = 1}    
	/  _=I  {position.y + bb.top > SHORTFINAL2}  cNuqtaLikeUpperNoKT  cDiacriticUpper ^ _=M;
// high initial with nuqta OR diacritic
cIni     cMed  >  @I  @M {tooHigh = 1}   
	/  _=I  {position.y + bb.top > SHORTFINAL1}  cNuqtaLikeLower? (cNuqtaLikeUpperNoKT  cDiacriticUpper) cDiacriticLower? ^ _=M;
// high initial with no nuqta or diacritic
cIni     cMed  >  @I  @M {tooHigh = 1}
	/  _=I  {position.y + bb.top > SHORTFINAL0}  g__kafTop_null? cNuqtaLikeLower? cDiacriticLower? ^ _=M;

csKafIM_medium  csMed_regular >  @I  csMed_short {tooHigh = 1} /  _=I  {tooHigh == 1 || position.y > SHORTFINAL_KAF}  MARKS ^ _=M;
csKafIM_medium  cMed          >  @I  @M {tooHigh = 1}          /  _=I  {tooHigh == 1 || position.y > SHORTFINAL_KAF}  MARKS ^ _=M;
csKafIM_base    cMed          >  @I  @M {tooHigh = 1}          /  _=I  {tooHigh == 1 || position.y > SHORTFINAL_KAF + 100m}  MARKS ^ _=M;

cMed  csMed_regular    >  @M  csMed_short {tooHigh = 1} /  _=M {tooHigh == 1}  MARKS  _=F;
cMed  cMed             >  @M1 @M2 {tooHigh = 1}   / _=M1 {tooHigh == 1}  MARKS ^ _=M2; // propagate too-high flag to the end of the word
cMed  csFinal_regular  >  @M  csFinal_short       / _=M  {tooHigh == 1}  MARKS  _=F;

endpass;  // 6 (13)
endif;


pass(7)  // 14

// Due to an infelicity in the Graphite engine, we can't substitute and attach in the same rule,
// so we have to do it in a separate pass.

table(glyph)
ckafTop_bjDia { kafTopM = point(kafTop_bjM.x, kafTop_bjM.y) }; // to avoid warnings; will never be used
endtable;


// Special case - the short kaf tops don't work for .jm form, so substitute special forms.
// Is this rule needed??
gKafMedJm_base (g__kafMedTop_short g__gafMedTop_short)  >  (gKafMedJm_short gGafMedJm_short)$2 g__kafTop_m_bogus  / ^ _ _;

// Special case: reattach to the short lam (because it is a different width).
cIniMed {att {to=@L; with=exit; at=entrance}}  gLamMed_short {insert = 1}
	/  _=P  MARKS2N ^ _=L;

// Special case: reattach nuqta-like things (small V, small tah) to short lam.
cLam_short (g__smallV g__smallTah) { attach {to = @L; at = nUpperS; with = nUpperM };
		shift.x = -100m }
	/  _=L  _=V  cDiacritic? ^ cBase;  // precedence

// Special case: reattach the short lam before the adjusted gaf (because the gaf is a different width).
cLam_short {att {to = @G; at = entrance; with = exit}}  gGafMedKf_lm {insert = 1}
	/  _=L  MARKS ^ _=G;


// ngoeh nuqtas
(gGafIniMm_short gGafMedJm_short gGafMedJm_tall) 
	cNuqtaUpper { att { to=@K; at=nUpperS; with=nUpperM }; passKeySlot = true }
	/  _=K  g__kafTop_m_bogus  _=N;

cTakes_kafTop_bjDia=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true}
	cNuqtaUpper { shift.y += @T.ktDelta;  collision.flags = SET_FIX(collision.flags) };
cTakes_kafTopDia=B     cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM};    passKeySlot = true}
	cNuqtaUpper { shift.y += @T.ktDelta;  collision.flags = SET_FIX(collision.flags) };

table(glyph)
cKafAltHt_full = (gKafIniMm_short  gGafIniMm_short  gKafMedJm_lowentry  gGafMedJm_lowentry);
		// gKaf/GafMedJm_short, gKaf/GafMedJm_tall - not used?
endtable;

// ring
cKafAltHt_full  g__attachedRingMid { attach { to=@K; at=ringS; with=ringM }; passKeySlot = true }
	/  _=K  g__kafTop_m_bogus  _=R;

cTakes_kafTop_bjDia=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };
cTakes_kafTopDia=B     cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}   // 26
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };


// Where there are two kafs in a row with a ring/nuqta/graf-stroke on the first, the latter will not get attached
// in this pass. This is because there is a conflict between the rule (above) that reattaches the ring/nuqta/graf-stroke
// and the rule (below) that reattaches to the following kaf base. So we do the ring/nuqta/graf-stroke attachment
// in a later clean-up pass.

// graf
cKafAltHt_full  g__grafStroke { attach { to=@K; at=grafS; with=grafM }; passKeySlot = true }
	/  _=K  g__kafTop_m_bogus  _=R;

cTakes_kafTop_bjDia=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	g__grafStroke { attach { to=@T; at=grafS; with=grafM }; passKeySlot = true };
cTakes_kafTopDia=B     cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}
	g__grafStroke { attach { to=@T; at=grafS; with=grafM }; passKeySlot = true };


// medial kaf bases - re-attach previous to medial kaf base
cTakes_kafTop_bjDia {att {to=@K2; with=exit; at=entrance}}  
	ckafTop_bjDia {att {to=@K1; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true}
	csKafMed_base {insert=1}
	/ _=K1  _=T  MARKS ^ _=K2;

cTakes_kafTopDia {att {to=@K2; with=exit; at=entrance}}    // 38
	cKaf_top {att {to=@K1; at=kafTopS; with=kafTopM}; passKeySlot = true}
	csKafMed_base {insert=1}
	/ _=K1  _=T  MARKS ^ _=K2;

cIniMed {att {to=@K; with=exit; at=entrance}}  csKafMed_base {insert=1} / _=P  MARKS2N ^ _=K;  // 53


// kaf tops
cTakes_kafTop_bjDia=B  ckafTop_bjDia {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true};
cTakes_kafTopDia=B     cKaf_top      {att {to=@B; at=kafTopS;    with=kafTopM};    passKeySlot = true};  // 55

// Alt-height kaf tops before short finals - reprocess to attach to the short final;
// this is needed because attaching the kaf base to the final takes precedence over the rules above
// that attach the tops.
cTakes_kafTop_bjDia=K  ckafTop_bjDia {att {to=@K; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true}  csFinal_short {reattached=1}
	/  ^ _=K  _=T  MARKS _=F {reattached==0};
cTakes_kafTopDia=K     cKaf_top      {att {to=@K; at=kafTopS;    with=kafTopM};    passKeySlot = true}  csFinal_short {reattached=1}
	/  ^ _=K  _=T  MARKS _=F {reattached==0};


// Currently no short bariyeh
/*******
table(glyph)
// Use a slightly higher AP when attaching to a short bariyeh, to save a little more space:
c_exit_bariyeh { exit_by_alt.x = exit.x + 12m; exit_by_alt.y = exit.y + 30m };
endtable;
c_exit_bariyeh {att {to=@F; with=exit_by_alt; at=entr_bariyeh}}	gBariyehFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
*******/

c_exit_chotiyeh {att {to=@F; with=exit; at=entrance}}     gChotiyehFin_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_chotiyehBfkl {att {to=@F; with=exit; at=entrance}} gChotiyehFin_bfkl_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_seen      {att {to=@F; with=exit;  at=entrance}}   gSeenFin_short     {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_sad       {att {to=@F; with=exit;  at=entrance}}   gSadFin_short      {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_jeem      {att {to=@F; with=exit;  at=entrance}}   gJeemFin_short     {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_ain       {att {to=@F; with=exit;  at=entrance}}   gAinFin_short      {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_noon      {att {to=@F; with=exit;  at=entrance}}   gNoonFin_short     {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_qafWaw    {att {to=@F; with=exit;  at=entrance}}   gQafFin_short      {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_qafWawStfh {att{to=@F; with=exit;  at=entrance}}   gQafFin_stfh_short {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_lamKaf     {att {to=@F; with=exit; at=entrance}}   gLamFin_short      {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_meem       {att {to=@F; with=exit; at=entrance}}   gMeemFin_short     {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_jeem       {att {to=@F; with=exit; at=entrance}}   gJeemMedBy_short   {passKeySlot = true; insert = 1}
	/  _ MARKS2N ^ _=F;
c_exit_beh        {att {to=@B; with=exit; at=entrance}}   
	gBehMedQf_short {att {to=@Q; with=exit; at=entrance};                       passKeySlot = true; insert = 1}
	(cQafFin cWawFin)
	/  _ MARKS2N ^ _=B MARKS2N  _=Q;


table(glyph) {AttributeOverride = 0}

// to avoid spurious warnings; will never be used
g__kafTop_null { nUpperS = point(0m,0m); kafTopM = point(0m,0m) };
g__kafTop_m_bogus { nUpperS = point(0m,0m); kafTopM = point(0m,0m); ringS = point(0m,0m) };
csFinal_short { hamzaUpperS = point(0m,0m); tahUpperS = point(0m,0m); n1LowerS = point(0m,0m); n23LowerS = point(0m,0m) };
cNuqtaLikeUpper { nUpperM = point(0m,0m) };
cNuqtaLikeLower { n1LowerM = point(0m,0m) };
cIsoFin { n1LowerM = point(0m,0m); mUpperS = point(0m,0m) };
cKafTop { mUpperS = point(nUpperS.x,nUpperS.y); n1LowerS = point(0m, 0m) };
cKafTop { grafS = point(0m, 0m); ringS = point(0m, 0m) };
gKafIniMm_short { grafS = point(0m,0m) };
gKafMedJm_lowentry { grafS = point(0m,0m) };
g__kafTop_by_tall_notused { grafS = point(0m,0m);  n1LowerS = point(0m,0m) };
// Temporary:
//g__kafIniTop_medshort_notused { n1LowerS = point(0m, 0m) };
g__gafIniTop_medshort_notused { n1LowerS = point(0m, 0m) };
g_space { honorificS = point(172m, 394m) };


g__kafTop_m_bogus { mUpperS = point(75m, 1545m) };

// Intersection class:
cTakes_smallV_short = csFinal_short;
cTakes_smallV_short &= cTakes_smallValtDia;

cTakes_ring_short = csFinal_short;
cTakes_ring_short &= cTakes_ringDia;

endtable;  // glyph


// Reattach nuqta-like glyphs.

csFinal_short  chamzaUpperDia {att {to=@F; at=hamzaUpperS; with=hamzaUpperM}} / _=F  _;
csFinal_short  ctahUpperDia   {att {to=@F; at=tahUpperS; with=tahUpperM}}     / _=F  _;
csFinal_short
	cn23LowerDia {att {to=@F; at=n23LowerS; with=n23LowerM}; collision.flags = SET_FIX(collision.flags)}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
cTakes_ring_short
	g__attachedRing {att {to=@F; at=ringS; with=ringM}}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
csFinal_short
	cNuqtaLikeLower {att {to=@F; at=n1LowerS; with=n1LowerM}}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
cTakes_smallV_short cNuqtaLikeUpper {att {to=@F; at=smallValtS; with=nUpperM}}  / _=F {lamValt == 1} _;
csFinal_short       cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}     / _=F  _;
csFinal_short       cn23LowerDia    {att {to=@F; at=n23LowerS; with=n23LowerM}} / _=F  _;
csFinal_short       cNuqtaLikeLower {att {to=@F; at=n1LowerS; with=n1LowerM}}   / _=F  _;
cTakes_ring_short   g__attachedRing {att {to=@F; at=ringS; with=ringM}}         / _=F  _;

endpass;  // pos - 7 (14)


//
//	DIACRITIC ATTACHMENT
//

// Order of glyphs: base, nuqta below, nuqta above, diacritics below, diacritics above
// But if an upper diacritic is in a "closer" mark class (eg, cMark1), it can come before the lower diacritic.

pass(8)  // 15

// Attach diacritics
 
table(glyph) { AttributeOverride = false }

// Classes of nuqtas and things that attach closely like nuqtas.
// These are basically defined for the purpose of ignoring in the context of attaching
// diacritics to things.
c_attLikeNqUpper = (cNuqtaLikeUpper); // includes small tah
c_attLikeNqLower = (cNuqtaLikeLower, g__hehHook_small);
c_attLikeNqLowMid = (c_attLikeNqLower, cNuqtaLikeMiddle,
	cKafTopInvis); // diacs don't attach to these, so attach to the base even if this is there
c_attLikeNqUpMid = (c_attLikeNqUpper, cNuqtaLikeMiddle);

// To avoid warnings in special-case attachment rules:
gTahFin { n1LowerS = point(mLowerS.x, mLowerS.y) };
gTehMarbutaFin  { n1LowerS = point(mLowerS.x, mLowerS.y) };
gHamzaBelow { nByLowerM = point(n1LowerM.x, n1LowerM.x + 200) };
gHamzaBelowArabic { nByLowerM = point(n1LowerM.x, n1LowerM.x + 200) };
gWavyHamzaBelow { nByLowerM = point(n1LowerM.x, n1LowerM.x + 200) };
g__smallTah2dotsBelow { nByLowerM = point(n1LowerM.x, n1LowerM.x + 200) };
g__dot2l_tail { nByLowerM = point(n1LowerM.x, n1LowerM.x + 200) };
g__attachedRing { nByLowerM = point(0m, 0m) };
g__ring { nByLowerM = point(0m, 0m) };


// For attachments after lam/feh/ain:
cMeemMF { nUpperS_left.x = nUpperS.x - 250m; nUpperS_left.y = nUpperS.y - 300m };

// For special cases involving nuqtas:
cNuWide = (cDot2u  cDot3u  cDot4u);
cNlWide = (cDot2l  cDot3l  cDot4l);
cNuqtaWide = (cNuWide  cNlWide);
cDRW_IF = (cDalIso cDalFin cRehIso gRehFin_jkl cWawIso cWawFin);
cRehFin_longtail = (gRehFin, gRehFin_hgM);

endtable;  // glyph


// To make it easy to change whether or not we allow insertions before diacritics:
#define SETDIACINS
// ...which is more efficient but equivalent to:
//#define SETDIACINS insert=false


/****
// Alternate approach to honorifics with diacritics - attach them to the diacritic:
table(glyph)
gZabar { honorificS = point(-200m, 300m) };
gPesh { honorificS = point(-200m, 300m) };
endtable;

cDiacriticUpper=D  chonorificDia=H {att {to=@D; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^ _  _ {att.to==0};
****/

// Special case: beh/peh + upper diacs + honorific - move honorific further off to the left
// (it normally goes where upper diacs go).
(cBehFin gBeh)=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; SETDIACINS}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; shift {x = 800m; y=400m}; SETDIACINS }
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// Special cases: initial-lam/feh/ain + meem + diac (medial lam has a little more space to the left):
cMeemMF  cDiacriticUpper {att {to=@M; at=nUpperS_left; with=mUpperM}; SETDIACINS}
		/ (gLamIniMm)  MARKS  _=M  _=D;
// Special case: wide nuqta + meem + diac
cMeemMF  cDiacriticUpper {att {to=@M; at=nUpperS_left; with=mUpperM}; SETDIACINS}
		/ cNuWide  cDiacritic?  _=M  _=D;
// Special case: lam/kaf + meem + diac
cMeemFin  cDiacriticUpper {att {to=@M; at=nUpperS_left; with=mUpperM}; SETDIACINS}
		/ (cLamIM cKafIM)  MARKS  _=M  _=D;

// diacritic AND honorific attached to final base or its nuqta;
// honorific is positioned off to the left
cIsoFin=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; SETDIACINS}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

cTakes_alefDia=B  
	gKharizabar=D {att {to=@B; at=alefS; with=mUpperM}; SETDIACINS}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

cIsoFin=B  
	cDiacriticUpper=D {att {to=@B; at=mUpperS; with=mUpperM}; SETDIACINS}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// honorific attached to final beh with lower nuqtas, w/o upper diac - 
// uses standard upper nuqta location raised a little higher
cBehFin=B  chonorificDia=H {att {to=@B; at {x=nUpperS.x; y=nUpperS.y + 300m}; with=honorificM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};

// Special rules for reh + zair
// Word-medially it attaches at the normal place.
cTakes_mLowerWfDia=R  gZair {att {to=@R; at=mLowerS; with=mLowerM}; SETDIACINS}
	/  _=R  _=D  cIsoIni;

// Otherwise, it is word-final, so attaches it further to the left.
cTakes_mLowerWfDia=R  gZair {att {to=@R; at=mLowerWfS; with=mLowerM}; SETDIACINS};


// Nuqta + upper and lower diacritic
// Eg, noon-nuqta + noon-ghunna-mark + zair (\u0646\u0658\u0650)
cTakes_nUpperDia=B  cNuqtaUpper=N
	cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}}
	cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}};

// Diacritics on final noon need to be positioned higher
cNoonFin  (g__dot1u g__dot2u)=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; shift.y = 300m; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower? _=D {att.to==0};

// attach to nuqta
cTakes_mUpperDia  c_attLikeNqUpper=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower? _=D {att.to==0};
cTakes_mLowerDia  c_attLikeNqLower=N  cDiacriticLower {att {to=@N; at=mLowerS; with=mLowerM}; SETDIACINS}
		/ ^ _=B  _=N  c_attLikeNqUpMid?  _=D {att.to==0};


// Special contextual cases - eg, kaf/lam followed by tailed final 
cTakes_mLowerCDia=B  cDiacriticLower {att {to=@B; at=mLowerCS; with=mLowerM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0}  (gAinFin gChotiyehFin gChotiyehFin_bfkl gJeemFin);

// Only a few glyphs attach the small alef at a special place.
cTakes_alefDia=B  gKharizabar {att {to=@B; at=alefS; with=mUpperM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Diacritics attach to tah above the stem, not where the nuqta goes:
cTakes_mTahUpperDia=B  cDiacriticUpper {att {to=@B; at=mTahUpperS; with=mUpperM}; SETDIACINS}
		/  ^ _=B  c_attLikeNqUpper?  cDiacriticLower?  _=D {att.to==0};

// Attaching dagger-alef to lam:
cLamIMF=L     gKharizabar {att {to=@L; at=nUpperS; with=mUpperLamM}; SETDIACINS};
gLam=L                 gKharizabar {att {to=@L; at=mUpperS; with=mUpperLamM}; SETDIACINS};
// dagger-alef is also slightly to the left for meems:
(cMeemIni cMeemMed)=M  gKharizabar {att {to=@M; at=nUpperS; with=mUpperLamM}; SETDIACINS};
(cMeemFin cMeemIso)=M  gKharizabar {att {to=@M; at=mUpperS; with=mUpperLamM}; SETDIACINS};

// Attaching to final form, or nuqta, uses mUpper/LowerS.
cTakes_mUpperDia=B  cDiacriticUpper {att {to=@B; at=mUpperS; with=mUpperM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_mLowerDia=B  cDiacriticLower {att {to=@B; at=mLowerS; with=mLowerM}; SETDIACINS}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Taller or shorter kafs - attach to top, not base
cTakes_nUpperDia  cKafTopAltHt  cDiacriticUpper {att {to=@T; at=nUpperS; with=mUpperM}; SETDIACINS}
		/ ^ _=B  _=T  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};


// Attaching to initial/medial base - uses stationary nuqta APs.
cTakes_nUpperDia=B  cDiacriticUpper {att {to=@B; at=nUpperS; with=mUpperM}; SETDIACINS}
		/ ^ _=B  cKafTopInvis?  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_n1LowerDia=B  cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}; SETDIACINS}
		/ ^ _=B  cKafTop?  c_attLikeNqUpMid?  _=D {att.to==0};

// Attach to diacritic
cDiacriticUpper=D1  cDiacriticUpper {att {to=@D1; at=mUpperS; with=mUpperM}; SETDIACINS}
	/ _=D1 ^ _=D2 {att.to==0};
cDiacriticLower=D1  cDiacriticLower {att {to=@D1; at=mLowerS; with=mLowerM}; SETDIACINS}
	/ _=D1 ^ _=D2 {att.to==0};

// Not needed because we have a nuqta+smalltah glyph:
////c_attLikeNqUpper=N  g__smallTah=T {att {to=@N; at=mUpperS; with=mUpperM} };

endpass; // pos - 8 (15)


// Left-over stuff

#define OPT_LOWER  cNuqtaLikeLower? cDiacriticLower?
pass(9)  // 16

// Hamzas that act like diacritics (but don't reattach them if they're already attached).
// Ideally these rules should handle 
cTakes_hamzaUpperDia   cHamzaAbove  /  _ ^ _; // already attached
cTakes_hamzaLowerDia   cHamzaAbove  /  _ ^ _;
cTakes_mTahUpperDia=B  cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mTahUpperS; with=hamzaUpperM}} / _ ^ OPT_LOWER _ ;  // tah
cTakes_mUpperDia=B     cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mUpperS; with=hamzaUpperM} }  /  _ ^ OPT_LOWER _ ;
cTakes_nUpperDia=B     cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@B; at=nUpperS; with=hamzaUpperM} }  /  _ ^ OPT_LOWER _ ;
cTakes_mLowerDia=B     cHamzaBelow {collision.flags = SET_FIX(collision.flags); att {to=@B; at=mLowerS; with=hamzaLowerM} }  /  _ ^ OPT_LOWER _ ;
cTakes_n1LowerDia=B    cHamzaBelow {collision.flags = SET_FIX(collision.flags); att {to=@B; at=n1LowerS;with=hamzaLowerM} }  /  _ ^ OPT_LOWER _ ;
cTakes_nUpperDia    cKafTopAltHt=T  cNuqtaLike4Kaf?
                       cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@T; at=nUpperS; with=hamzaUpperM} } / _ _ _ ^ OPT_LOWER _ ;
cTakes_nUpperDia=K  cKafTopInvis  cNuqtaLike4Kaf?
                       cHamzaAbove {collision.flags = SET_FIX(collision.flags); att {to=@K; at=nUpperS; with=hamzaUpperM} } / _ _ _ ^ OPT_LOWER _ ;
                       
                       
// Nuqtas/ring/graf stroke will not be properly attached to a kaf-top when it is followed
// by another kaf or gaf, due to the interaction of the rules. Just reattach them all.

cKafTopAltHt=T  g__grafStroke { attach { to=@T; at=grafS;   with=grafM }};
cKafTopAltHt=T  cringDia      { attach { to=@T; at=ringS;   with=ringM }};
// Special case: kaf-3-dots + kaf
////cKafTopAltHt    g__dot3u      { attach { to=@T; at=nUpperS; with=nUpperM }; shift { x = -220m; y = 150m } }  //// ####
////	/ gKafMedKf_wide_base _=T  _=N  cKafMed  g__kafTop_null;
// Special case: ngoeh/graf + kef
cKafTopAltHt    cNuqtaUpper   { attach { to=@T; at=nUpperS; with=nUpperM }; shift { x = -450m; y = 270m } }
	/  _=T  _=N  csKafMed_baseT  csKafMed_top_tall;
cKafTopAltHt=T  cNuqtaUpper   { attach { to=@T; at=nUpperS; with=nUpperM }};


// Diacritic tweaks

// Special case: nuqtas and diacritic get reversed to do narrowness of beh and kaf.
////cNuqtaLower {shift.x = -350m} cDiacriticLower {shift.x = 220m}                   //// ####
////	/ (gBehIni  gBehMed) _=N  cNuqtaLikeUpper? cDiacritic? (gKafMedJm gGafMedJm) g__kafTop_null _=D;

endpass; // pos - 9 (16)


// Kerning pair adjustments

table(glyph) { AttributeOverride = 1 }

// alef, dal, reh, reh-sshg, reh-jkl, reh-???, waw, heh-goal, noon

cKernable { kernPreAlef = 0m; kernPreDal = 0m; kernPreReh = 0m; kernPreZain = 0m;
	kernPreWaw = 0m; kernPreMeemJeem = 0m; kernPreJeemAinIso = -130m; kernPreLamAlef = 0m; 
	kernPreKafNoSp = 0m; kernPreShort = 0m; kernPreExclam = 0m;
	minKernDelta = 0m };

cDalIso		{ kernPreAlef = -60m };
cDalFin		{ kernPreAlef = -50m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m };
cRehIso		{ kernPreAlef = -50m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m;
				kernPreMeemJeem = 70m;
				// Before a two-letter sequence:
				kernPreShort = 80m };
gRehFin_jkl	{ kernPreAlef = -70m; kernPreJeemAinIso = -150m; kernPreMeemJeem = 60m };
cDalFin     { kernPreMeemJeem = 70m };
gWaw		{ kernPreAlef = -30m; kernPreReh = 40m };

//gDalFin		{ minKernDelta = -200m };
//cRehIso		{ minKernDelta = -200m };
//gRehFin_jkl	{ minKernDelta = -400m };
//gRehFin_sshg { minKernDelta = -400m }; -- obsolete
gRehFin		{ minKernDelta = -400m; kernPreAlef = -70m };   // long tail
gRehFin_hgM { minKernDelta = -400m; kernPreAlef = -70m };	   // long tail

gAlef { kernPreZain = -60m };
gAlefFin { kernPreZain = -60m };

// Don't let punctuation kern underneath the following segment;
#if KERNLOWPUNCT
cHighPunct { minKernDelta = MINKERN * -1   -  300m };  // cancels out MINKERN
#else
cKernPunct { minKernDelta = MINKERN * -1   -  300m };  // cancels out MINKERN
#endif

// To account for the fact that the top edge of the kaf pushes the top of the alef away:
///gAlef { kernPreKafNoSp = -150m };
///gAlefFin { kernPreKafNoSp = -80m };


// Digits

cDigitArabic  { kernPreZero = 0m; kernPreOne = 0m; kernPostOne = 0m };
cDigitEastern { kernPreZero = 0m; kernPreOne = 0m; kernPostOne = 0m };

gEasternSeven { kernPreZero = 125m };

gOne { kernPreOne = 50m };
gEasternOne { kernPreOne = 50m };
gNine { kernPreOne = 50m };
gEasternNine { kernPreOne = 50m };
gSix { kernPreOne = 50m };
gEasternSix { kernPreOne = 50m };

gTwo { kernPostOne = 50m };
gEasternTwo { kernPostOne = 50m };
gThree { kernPostOne = 50m };
gEasternThree { kernPostOne = 50m };

// Finals with little tails:
gTah { kernPreExclam = -200m };
cTahFin { kernPreExclam = -200m };
gHehDo { kernPreExclam = -250m };
cHehDoFin { kernPreExclam = -250m };
gWaw { kernPreExclam = -70m };
cWawFin { kernPreExclam = -70m };

// Dal/reh/waw isolates with nothing above:
DRW_F_noupper = (gReh gRehDotBelow gRehRing gWaw gWawRing gKirghizOe gDal gDalDotBelow gDalRing);

endtable; // glyph


pass(10)  // 17

// Special cases involving nuqtas.

// Special case: \u0631\u06CC\u0631, \u0634\u0632\u062F\u06CC\u0648
cNuqtaLikeLower {shift {x = 170m; y = -400m}}
	/  cDRW_IF=DR MARKS  (gBehIniRe gBehIniQf)=B _=N cDiacritic?  (gRehFin_jkl cWawFin)=RW;

// Special case: \u063A\u0632\u06CC\u0631; see also pass below where the margin for the reh is adjusted
cRehFin_longtail {collision.margin=30m}  (gBehIniRe gBehIniQf)  cNuqtaLikeLower {shift {x = -80m; y = 150m}}  (gRehFin_jkl cWawFin)
	/  _=R cNuqtaLike? cDiacritic?  _=B _=N cDiacritic?  _=RW;

// Special case: \u0627\u06CC\u0645\u0627
#if WEIGHT >= WT_BOLD
gAlef  gBehIniMmX  cNlWide {shift {x = 300m; y = -800m}}  gMeemMed_alt;
#else
gAlef  gBehIniMmX  cNlWide {shift {x = 300m; y = -650m}}  gMeemMed_alt;
#endif

// Special case: gaf + pesh + gaf (\u06af\u064f\u06af)
// Move diacritic to the right; there is no good place for it.
csKafIM_base  cKafTop  cDiacriticUpper {shift {x = -800m; y = 100m}} cKafNoIso;

// Special case: \u06a9\u0648\u062a\u0645\u06c1\u0627 - NOT NEEDED?
//gWawFin { pairKern = 80m }
//	/  _  gBehIniMm  cNuqtaLikeUpper?  gMeemMedHgM  gHehGoalMed  g__hehHook_small  cAlefFin;

// Special case: reh + Arabic hamza
(gReh gZain gHehGoalFin) { pairKern = 50m }  /  _  gArabicHamza;

// Special case: feh/qaf + diac + kaf/gaf
cNuqtaUpper { shift { x = -100m; y = -100m } }
	cDiacriticUpper { shift.x = -250m }
	/  cFehIni  _=N  _=D  (cKafMed csKafMed_base);

// Special case: initial beh/peh/yeh + beh/peh/yeh
// Leave FIX off for the right-most nuqtas so they don't shift back.
cNlWide { shift { x = 300m; y = -200m } }
	cNuqtaLower { shift { x = 350m; y = -200m } }  // we don't expect collisions
	/  (gBehIniBe gBehIniBeM1) _=N1 cDiacritic? 
		(gBehMedAi gBehMedFe gBehMedSd gBehMedBeF gBehMedSn gBehMedSnSn) _=N2;
cNlWide { shift { x = 300m; y = -130m } }
	cNuqtaLower { shift { x = 300m; y = -360m } }  // avoid the final reh
	/  gBehIniBeRe _=N1 cDiacritic?  gBehMedRe _=N2;
cNuqtaLower { shift { x = 200m; y = -200m } }
	cNuqtaLower {
		shift { x = 300m; y = -200m }
		// ; collision.flags = SET_FIX(collision.flags) -- hopefully don't need this
	}
	/  gBehIniBe  _=N1 cDiacritic?  (gBehMedAi gBehMedFe gBehMedSd)  _=N2;
//cNlWide { shift { x = 350m; y = -200m } }
//	cNuqtaLower { shift { x = 250m; y = -250m }; collision.flags = SET_FIX(collision.flags) }
//	cNuqtaLower { shift { x = 250m; y = -250m }; collision.flags = SET_FIX(collision.flags) }
//	/  gBehIniBeRe _=N1 cDiacritic?  gBehMedRe _=N2 [cDiacritic?  gRehFin _=N3]?;

// Special case: jeem/khah + meem/beh/heh-goal (narrow) + upper diac
cDiacriticUpper { shift.x = 250m }
	/  cJeemIM  MARKS  (cMeemMed cBehMed cHehGoalMed)  cNuqtaLower?  _=D;

// Special case: kerning - reh + feh/qaf + reh
(gRehFin_jkl gReh gDalFin) { pairKern += 150m }
	/  _=R  (gFehIniRe gHehDoIniRe);

// Special cases: reh + yeh - shift yeh nuqtas left and reh down
// TODO: handle a bariyeh after the beh-ini (\u067E\u06CC\u0631\u06CE\u0646\u06D2)
gRehFin_jkl {shift.y = -200m }   cNuqtaLower { shift {x = 250m; y = -10m} }   // -300 was -150; -30 was 150m
	/ _=R MARKS  cBehIni _=N { 0m < position.y && position.y < 300m };
gRehFin  {shift.y = -150m }   
	cNuqtaLower { shift {x = 50m; y = 100m} }
	/ _=R MARKS  cBehIni _=N { -550m < position.y && position.y < 0m } ;
gRehFin  {shift.y = -150m }   cNuqtaLower { shift {x = 180m; y = 80m} }
	/ _=R cBehIni MARKS cBehMed _=N { -450m < position.y && position.y < 200m } ;

// Special case: keep nuqta from sitting on top of reh:
gRehFin_jkl { shift.y = -30m } cNuqtaLower {shift {x = 200m }} / _=R  cDiacritic?  gBehIniHd _=N;
// another way to do it:
//gRehFin_jkl { pairKern = 80m } cNuqtaLower {shift {x = -150m; y = 600m }} / _=R  cDiacritic?  gBehIniHd _=N;

// Special case: waw/dal/reh + jeem + yeh; no agreement on how to fix this
//cNuqtaLower { shift { x = 130m; y = -500m } }      // move it down
//cNuqtaLower { shift { x = 100m; y = 800m } }       // move it up
//	/ (DRW_F_noupper cWawFin cDalFin gRehFin_jkl) MARKS  gJeemIniCh _=N cDiacritic?  cChotiyehFin;

// Low priority special case:
////gRehFin {collision.margin = 50m; marginSet = 1}  gBehIniFe  cNlWide; /// {shift {x = 150m; y = 70m}; collision.margin = 50m};

// Special case: closing paren + quote
// TURN ON FOR BUG:
g_parenleftArab { pairKern = -200m }  /  _  cQuoteLeftArab;
// The auto-kerning mechanism didn't want to fix this for some reason. Just do standard kerning.
// TURN OFF FOR BUG:
////cQuoteLeftArab { kern.x = -100m }
////	/  g_parenleftArab  _;

// Special case: yeh + beh + yeh - spread nuqtas out - not needed with new pos for gBehMedCh
////g__dot2l { shift { x = -130m; y = -170m; } }
////	g__dot1l { shift { x = 50m; y = -220m } }
////	/  gBehMedBe  _=N2  gBehMedCh  _=N1;

// Special case: jeem + noon/teh + shadda + noon/teh
gShadda { shift{ x = 10m; y=200m } } (g__dot1u g__dot2u) { shift{x = 230m; y=-50m} }
	/ cJeemIM  gBehMedBeM1  cNuqtaLower?  _=S  gBehMedBeM2 _=N  cDiacritic?  gBehMed  cNuqta  cKafMF;

// Special case: zair + beh/yeh + bariyeh. The sequencing gets confused because the diacritic is
// higher than the nuqta (below the bariyeh tail).
gZair { shift {x=-200m; y=250m } }  cNuqtaLikeLower { sequence.class = 0; shift.x = 200m }
	/  _=Z gBehMedBy  _=N  cDiacritic?  gBariyehFin;

// Special case:
////cNuqtaLikeUpper {shift.y = -150m}  cDiacriticUpper {shift {x = -150m; y = -250m}}    //// ####
////	/  (cFehIM cAinIM) _=N  _=D  cNarrowPreKaf  MARKS  csKafFinTall;

// Special case: feh/ain + wide-jeem + final-kaf


// Special case: kaf+3dots + kaf-fin
g__dot3u { shift.x = -100m }
	/ gKafMedKf_wide_base  g__kafMedTop_tall _=N  cDiacritic? gKafFin;


cNuqtaLower {shift.y = 300m}  /  gBehMedCh  _=N  cDiacritic?  gChotiyehFin_short;



// Set up kerning pairs.

cKernable { pairKern = kernPreAlef }		/  _ ^ MARKS  cKernIgnore?  cAlefIso;
cKernable { pairKern = kernPreDal  }		/  _ ^ MARKS  cKernIgnore?  cDalIso;
cKernable { pairKern = kernPreZain }		/  _ ^ MARKS  cKernIgnore?  cZainIso;
cKernable { pairKern = kernPreReh  }		/  _ ^ MARKS  cKernIgnore?  cRehIso;
cKernable { pairKern = kernPreWaw  }		/  _ ^ MARKS  cKernIgnore?  cWawIso;
cKernable { pairKern = kernPreJeemAinIso }	/  _ ^ MARKS  cKernIgnore?  (cJeemIso cAinIso);
cKernable { pairKern = kernPreLamAlef}		/  _ ^ MARKS  cKernIgnore?  gLamIniAl;  // gLafAlef - no longer used
cKernable { pairKern = kernPreExclam }		/  _ ^ MARKS  cKernIgnore?  g_exclamArab;
// Strictly speaking this should only apply to jeems that are right near the baseline, but too hard to test for:
cKernable { pairKern = kernPreMeemJeem }     /  _ ^ MARKS  cKernIgnore?  (cMeemIso cJeemIni);

// Currently not being used:
////cKernable { pairKern = kernPreKafNoSp + @K.position.y }   /  _ ^ MARKS  (gKaf  gGaf  cKafIni)=K;


table(glyph)
// The kerning rule below doesn't apply to a kaf before a bariyeh, 
// although I'm not sure how much practical difference it makes.
cKafKludge = (cKafIni csKafIni_base cKafIso);  // kludge because these glyphs are in the classes twice
cKafKludge -= (gKafIniBy gGafIniBy );
cKafNoBy = cKafKludge;
cKafNoBy -= (gKafIniBy gGafIniBy);
endtable;

gAlefMaddaAbove { pairKern = -150m }  /  _ ^ MARKS  cKernIgnore?  cKafNoBy
	[MARKS  ANY]?;  // superfluous slots to increase precedence over two-letter sequence rule below

// Reh tweaking:

// Exception to pre-short rule:
cRehIso { pairKern = -40m }          /  _ ^ MARKS  cKernIgnore?  cBehIni MARKS  cAlefFin;

(cRehIso gRehFin_jkl) { pairKern = 60m }  /  _=R  MARKS  gBehIniRe=B  MARKS  gRehFin_jkl;

cRehIso { pairKern = 140m } /  _=R  MARKS  cSeenIso;

cRehIso { pairKern = 150m } /  _=R  MARKS  (gFehIniMm gMeemIniMm gLamIniMm);

DRW_F_noupper { pairKern = 200m }  /  _=RWD cDiacriticLower? MARKS  cKafIso;


// Before a two-letter sequence:
/////cKernable { pairKern = kernPreShort }  /  _ ^ MARKS  cKernIgnore?  cIni MARKS  cFin;

// Notice that with digits, which are LTR, we put the kern value on the opposite glyph, ie, the FOLLOWING
// glyph which will be right-most when rendered.
( gEasternZero  gZero ) { pairKern = @D.kernPreZero }   /  _  (cDigitEastern cDigitArabic)=D;
( gEasternOne  gOne )   { pairKern = @D.kernPreOne }    /  _  (cDigitEastern cDigitArabic)=D;
(cDigitEastern cDigitArabic) { pairKern = kernPostOne } /  _  ( gEasternOne  gOne );


// Special case: kern a little tighter against a low-positioned teh/yeh/peh with wide nuqta:
// I think this is only needed for preceding alefs.
(cAlefFin cAlefIso) { pairKern -= 150m }
	/  _  MARKS cSpace?  cBehIni cNuqtaWide { 100m < position.y && position.y < 1900m };


// Bogus rule that will never fire (for in case we disable this pass for debugging):
///////////////gRrehFin_jkl cDiacritic cDiacritic cDiacritic { user6 = 10 };


// Diacritics that extend above/below the line

cNuqtaLike?  cDiacriticUpper  /  (cKafIM csKafIM_base)  cKafTop  _  _;  // ... but not on kafs or gafs

// For tahs, the diac is not attached to the nuqta, so don't move the nuqta down.
cTahIM  cNuqtaUpper  cDiacriticUpper  { shift.y -= 200m; collision.margin -= 20m }
	/  _=T  _=N  _=D { position.y > 2800m };
cNuqtaLikeUpperNoKT { shift.y -= 150m  }
	cDiacriticUpper { shift.y -= 200m; collision.margin -= 20m }  /  _=N  _=D { position.y > 2800m };
cDiacriticUpper { shift.y -= 100m; collision.margin -= 150m } /  cKafIM  cNuqtaLikeUpper?  _ { position.y > 2800m };
cDiacriticUpper { shift.y -= 200m; collision.margin -= 70m }  /  _ { position.y > 2800m };
// -1350 permits a single diacritic under a standard bowl to remain at the standard position
cDiacriticLower { shift.y += 150m; collision.margin -= 70m }  /  _ { position.y < -1350m }; // was -1200


// Give name-marker (takhalus) a minumum height.
gNameMarker { shift.y += max(0, 2200 - position.y); };


endpass;  // 10 (17)


// Diacritic collision fixing and kerning

if (collFix > 0)

pass(11) // { CollisionFix = 4; AutoKern = true }  // 18

// Set up diacritic collision fixes and kerning.

// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags) };  /// collision.flags = SET_IGNORE(collision.flags) };

// Kaf exclusion glyphs don't affect diacritics.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision.exclude.glyph = 0 };

// Undo kludge above that avoids shifting .
cQuoteArab { collision.flags = CLEAR_IGNORE(collision.flags) };


// Never shift these!! (even though they are thought of as "nuqta-like" for some purposes).
cKafTop { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = CLEAR_FIX(collision.flags);
	};
	sequence.class = 0
};

#define SET_MARGIN(X)         max(0m, kernLsb + @X.kernRsb + pairKern)
#define SET_MARGIN_PLUS(X,Y)  max(0m, kernLsb + @X.kernRsb + pairKern + Y)

if (collFix >= 3)

// For special cases:
////cKernable {collision {
////	flags = SET_FIX(collision.flags);
////	max.x = MAXKERN; min.x = MINKERN + minKernDelta;}}
////	/  _ {marginSet == 1}  cNuqtaLike?  DIACS  cPostKernable;

// Special case: alef + zabar-two-dots + kaf/gaf - cozy alef + zabar-two-dots up to kaf/gaf.
(cAlefIso cAlefFin) {
	collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		//margin = SET_MARGIN_PLUS(K, -100m)
		margin = 170m;
		max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
 	} }  /  _  gZabarTwoDots cKafIso=K;

// Zabar-two-dots must stay centered over the alef.
gZabarTwoDots {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = 60m;  // normally -250
		max.x = 60m;
		min.y = -100m;
		max.y = 100m;
		margin = 100m;  // cozy up
	} }  /  (cAlefIso cAlefFin)  _  gMaddaAbove? cBase;  // increase precedence

// Other diacritics should be more or less centered over alef.
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = 120m;  // normally -250
		max.x = 60m;
		min.y = -100m;
		max.y = 100m;
	} }  /  (cAlefIso cAlefFin)  _  gMaddaAbove? cBase;  // increase precedence

// Dagger-alef is slightly to the left of lam.
// Eg: tah + pesh + seen
gKharizabar {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -5m;  // normally -250
		max.x = 5m;
		min.y = -50m;
		max.y = 50m;
	} }  /  cLamIMF  _  cBase;  // increase precedence

// Diacritics should stay centered over short-lam stems, but they may need to move a little.
// Eg: lam + pesh + kaf
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -5m;  // normally -250
		max.x = 100m;
		min.y = -100m;
		max.y = 200m;
	} }  /  (gLamIni_short gLamMed_short)  _  cKafMF;  // increase precedence

// Special case: round kaf-3dots + lam + upper diacritic
g__dot3u { shift {x=-200m; y=250m} }
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;  // normally -250
		max.x = 100m;  // might need to be off-center
		min.y = -100m;
		max.y = 200m;
	} }
	/ gKafIni  g__kafTop_null _=N cDiacritic?  cLamMed  _=D;


// Diacritics should stay centered over tah and lam vertical stems.
// Eg: tah + pesh + seen
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -30m;  // normally -250
		max.x = 30m;
		min.y = -100m;
		max.y = 200m;
	} }  /  cVerticalStem  _  cBase;  // increase precedence


// Special cases
/**
cDiacriticUpper { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	// Don't set sequence attributes; let the diac stay below the upper nuqta.
}  /  cFehIni  cNuqtaLikeUpper  (cHehGoalMed cMeemMed)  cNuqtaLikeLower?  _;
**/

// Special case: the diac AP on the meem and heh-goal is pretty far to the right,
// so they need to move left after a feh. Using the sequencing mechanism messes things up,
// so turn it off for those.
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	////sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  / cFehIM  cNuqtaUpper  cDiacritic?  (cHehGoalMed  cMeemMed)  g__hehHook_small?  _;

// Special case: lam/kaf + meem = upper diac + qaf - move diac up and to the left
cDiacriticUpper {
	shift { x = 300m; y = 350m; };
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 250m;
		min.y = -300m;
		max.y = 200m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  (cLamIM cKafIM)  cKafTopInvis?  cNuqtaLikeLower?  cMeemMed  cNuqtaLikeLower?  _  cFehMed;

// Special case: lam/kaf + meem + upper diac - move diac to the left
cDiacriticUpper {
	shift { x = 300m; y = -150m; };
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 250m;
		min.y = -300m;
		max.y = 200m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  (cLamIM cKafIM)  cKafTopInvis?  cNuqtaLikeLower?  cMeemMed  cNuqtaLikeLower?  _;

// Special case: upper diacritic before kaf cannot move very far left; in fact, shift it right
// Eg: \u0628\u06BE\u0627\u065E\u06AF\u06C1
// I can't figure out why this rule is needed, and shifting the diac right causes collisions
// (\u0644\u06be\u064e\u06a9\u0641). The movement limits are probably okay though.
cDiacriticUpper {
	//shift.x = -150m;
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m;
		max.x = 100m;  // 250
		min.y = -300m;
		max.y = 400m;  // less than normal
		// don't bother with sequence attributes
} }  /  (cMed  cIso) _  (cKafNoIso cKafIso);

// Special case: keep pesh under following kaf; nuqta on noon pushes it up too far.
// In fact, might as well apply this to tehs and other diacs as well.
cNuqtaUpperSmall { shift { x = -100m; y = -200m } }
	cDiacriticUpper { shift { x = -130m; y = -70m };
		collision { min.x = -50m; max.y = 50m; margin = 100m } } // keep it from moving back
	/  gBehIni  _=N  ^ _=D  csKafIM_base;

// Special case: heh-hook + lower diac + lower nuqta + bariyeh
cNuqtaUpper { shift.y = -100m }
	cDiacriticUpper { shift { x = -150m; y = -150m };
		collision { min.x = -50m; max.y = 50m } } // keep it from moving back
	/  gSeenIni  _=N  ^ _=D  csKafIM_base;

// Special case: kaf + alt-meem + diac + lam
cDiacriticUpper {
	shift.y += 700m;
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -50m;  // normally -250
		max.x = 50m;   // normally 250
		min.y = -100m;
		max.y = 200m
	} }
	/  cKafIM  cKafTop  DIACS  gMeemMed_alt  _=D  (cAlefFin  cLamMF);

// Special case: khah + sheen; this is used in a key word in a certain language, so make it pretty. :-)
cNuqtaLikeUpper {shift.x = -100m}  cNuqtaLikeUpper {shift.x = 100m}
	/  gJeemMedSn  _=N1  cDiacritic?  cSeenMed  _=N2;

// Special case: upper nuqta + short kaf/gaf
cNuqtaLikeUpperNoKT { collision.flags = SET_FIX(collision.flags) }
	/  _=N  cDiacritic?  csKafMed_base;

// Special case: dal + noon
gDal { collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = STDMARGIN + 100m;
		max.x = MAXKERN; min.x = MINKERN;
    	// min/max.y are omitted for kernable glyphs
	} }
	/  _=D  gBehIniBeM2 g__dot1u  gBehMed  MARKS  gAlefFin;

// Special case: lam-alef + meem...
// Ideally this should handle marks as well, but the real-life example did not include any.
gAlefFin_lm { collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = STDMARGIN;  // tighter than normal
		max.x = MAXKERN; min.x = MINKERN;
    	// min/max.y are omitted for kernable glyphs
	} }
	/  _=A  gMeemIniBe gBehMedCh  cNuqtaLike?  gChotiyehFin;

// Special case: final-meem + beh + yeh...
// Ideally this should handle marks as well, but the real-life example did not include any.
gMeem { collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = SET_MARGIN_PLUS(B, 170m);  // looser than normal
		max.x = MAXKERN; min.x = MINKERN;
    	// min/max.y are omitted for kernable glyphs
	} }
	/ _=M g_space gBehIniBeM1=B cNuqtaLike? gBehMedBe cNuqtaLike? gBehMedMm cNuqtaLike? gMeemMedNn;

// Special case: reh + honorific needs more kerning
gReh { collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = SET_MARGIN(N);  // +200 - no
		max.x = MAXKERN; min.x = MINKERN;
    	// min/max.y are omitted for kernable glyphs
	} }
	/ _=R ^ chonorificDia  cKernIgnore?  cPostKernable=N;

// Special case: alef + hamza + waw
// The diacritic/harakat on the alef can collide with the segment following the waw/dal/reh,
// so add some kerning margin.
/***
(gWaw gDal gReh) { collision {
		//flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = SET_MARGIN_PLUS(N, 150m);
		max.x = MAXKERN; min.x = MINKERN;
    	// min/max.y are omitted for kernable glyphs
	} }
	/ gAlefFin (cNuqtaLikeUpper cDiacriticUpper) _=W  DIACS  cPostKernable=N;
***/


table(glyph)
cDiacKeepCentered = (gNoonGhunnaMark g__smallV gKharizabar gKharizair gJazm gShadda g__shadda_zabar);  // add any other combinations
cIM_BeM1 = (csIniBeM1 csMedBeM1); // high tooth
endtable;

// Special case: noon/teh + shadda + beh + kaf/gaf - needs to avoid kaf/gaf
cNuqtaUpper {shift.y = -100m}
	cDiacKeepCentered {
		shift { x = -60m; y = -150m };
		collision {
			flags = CLEAR_IGNORE(collision.flags);
			flags = SET_FIX(collision.flags);
			min.x = -100m;
			max.x = 100m;
			min.y = -300m;
			max.y = 800m;
		}
	}
	/ cIM_BeM1 MARKS  gBehMedBeM2 _=N  _=D  (gBehMed gHehGoalMed) MARKS  cKafFin;


gNameMarker  { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -400m;
	max.x = 400m;
	min.y = -300m;
	max.y = 800m;
} };

chonorificDia { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	margin = 300m; marginweight = 500; // don't squeeze these in!
	min.x = -400m;
	max.x = 0m;
	min.y = -50m;
	max.y = 700m;
} };

gKharizabar {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -50m; 	// don't let them move too far to the left, away from the lam
		max.x = 10m;	// the lam is on the right, so don't move that direction.
		min.y = -50m;
		max.y = 50m;
		margin = 100m;
	}
} / (cLamIM gLamFin gLam) _ ;


// Diacritics attached to finals - allow them to move more to the left
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -400m;  // normally -250
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cFin  cNuqtaLikeLower?  _;

//table(glyph)
//cBaseDontShiftDiac = cBase;
//cBaseDontShiftDiac -= (cIso, cMeemMed_alt, cIni);
//endtable;

// Diacritics attached to bases:
cDiacriticUpper {
	//////shift.x = 175m;   // I think this was a mistake, so I am removing it.
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;   // These two lines were commented out,
		max.y = 500m;    // but surely we need them. I think it was a mistake.
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cBase  cNuqtaLikeLower?  _;


cDiacriticLower { 
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m; // making this larger than ideal fixes \u0628\u0650\u06CC\u062C
		max.x = 300m;
		min.y = -1200m; // needed to get below nuqtas for sure; eg \u062A\u0648\u0641\u0650\u06CC\u0642
		max.y = 300m;    // CHANGE BACK TO 300
		//margin = 50m; // don't know why this was here
	};
	sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; }
}  /  cBase  cNuqtaLikeUpper?  _;


table(glyph)
cIsoWithUpperNuqta = (gTeh, gTheh, gTehRing, gTehThreeDotsAboveDownwards, gKhah, gHahThreeDotsAbove,
	gSheen, gSeenDotBelowDotAbove, gSeenFourDotsAbove, gSeenSmallTahTwoDots, gSeenTwoVertAbove,
	gSeen3DotsBelow3DotsAbove, gSeenInvertedVAbove, gSeenFourAbove, gDad, gZah, gGhain,
	gFeh, gQaf, gLamSmallV, gLamThreeDots, gLamSmallTah, 
	gNoon, gRnoon, gNoonDotBelow, gNoonSmallV, gNoonRing, gNoonRetro,
	gThal, gDdal, gDalDotBelowSmallTah, gDalTwoVertBelowSmallTah, gDalFourDotsAbove,
	gWawDotAbove, gWawTwoDotsAbove, gWawTwoAbove, gWawThreeAbove, gZain,gRreh, gJeh, gRehDotBelowDotAbove,
	gRehTwoDotsAbove, gRehTwoVertAbove, gRehSmallTahTwoDots, gYehSmallV, gYehTwoAbove, gYehThreeAbove,
	gBariyehTwoAbove, gBariyehThreeAbove );
endtable;

// These should always stay centered over the nuqta if any:
gKharizair { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -10m;
	max.x = 10m;
	min.y = -1000m;  // needs quite a bit to clear final jeem
	max.y = 300m;
} }  /  (cNuqta cIsoWithUpperNuqta)  cDiacritic?  _;

// These should always stay centered over the nuqta if any:
cDiacKeepCentered { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -10m;
	max.x = 10m;
	min.y = -300m;
	max.y = 500m;
} }  /  (cNuqta cIsoWithUpperNuqta)  cDiacritic?  _;

cDiacriticUpper { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 250m;
	min.y = -300m;
	max.y = 500m;
} };


cDiacriticLower { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -300m; // making these larger than ideal fixes \u0628\u0650\u06CC\u062C
	max.x = 300m;
	min.y = -800m;
	max.y = 300m;
} };

endif; // (collfix >= 2) - shift fixes


// KERNING
// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.

/******
if (overlapKern == none)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == wide)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
//	max.x = MAXKERN; min.x = MINKERN_TIGHT; margin = KERNMARGIN_MED;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == medium)
******/


// Don't let a single-letter word kern underneath following segment:
cIso { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(N);
	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
    // min/max.y are omitted for kernable glyphs
} }
	/  cSpace  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// Don't let an isolate alef kern too far - it's so thin that it looks odd and gets lost.
/****
gAlef { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(N);
	max.x = MAXKERN; min.x = -275m + minKernDelta;    // = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=A  cNuqtaLike?  DIACS  cPostKernable=N;  // make context long enough for precedence 
****/


// EXPERIMENT - don't allow ANY overlap between words
//cKernable { collision {
//	flags = SET_FIX(collision.flags);
//	flags = SET_KERN(collision.flags);
//	margin = SET_MARGIN(N);
//	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
//    // min/max.y are omitted for kernable glyphs
//} }
//	/  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// Special case; also see previous pass where nuqtas are shifted up
// \u063A\u0632\u06CC\u0631
cRehFin_longtail { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = 130m;
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=R  cNuqtaLike? cDiacritic?  (gBehIniRe gBehIniQf)  cDot3l cDiacritic? (gRehFin_jkl cWawFin);


// Special case: \u062A\u0627\u0631\u06CC\u062E\u06CC
// Don't allow the reh to kern underneath the lower nuqtas; also shift nuqtas up.
(gReh gRehDotBelow gWaw) { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = -400m;
    // min/max.y are omitted for kernable glyphs
} }
	cNuqtaLower {shift.y = 150m}
	/  _=R  gBehIniJm  _=N;

// Special case: \u06af\u0648\u064e\u0634\u062a\u0634
// Use a little less kerning and push the diacritic down.
(cWawFin cDalFin) { collision {
 		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = SET_MARGIN(S);
		max.x = MAXKERN; min.x = min(0m, MINKERN + minKernDelta + 100m);
    	// min/max.y are omitted for kernable glyphs
	} }
	cDiacriticUpper {shift.y = -200m}
	/  _=F  _=D  gSeenIniBeM1=S  MARKS  gBehMedSn  MARKS  gSeenFin;

// Special case: \u0633\u0631\u0641\u0631
gRehFin { collision {
 		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = SET_MARGIN_PLUS(FA, 65m);
		max.x = MAXKERN; min.x = min(0m, MINKERN - 500m + minKernDelta);
    	// min/max.y are omitted for kernable glyphs
	} }
	/  _=R /*no marks*/  (gFehIniRe gAinIniRe)=FA  MARKS  cRehFin;

// Special case: zain + isolate
g__dot1u { shift.x -= 150m }
	/ gRehFin  _=N  (gDal gWaw gAlef gSeen gTah gFeh gQaf gMeem gHehDo gHehGoal) ;


cRehFin_longtail { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = 80m;
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=R  cNuqtaLike? cDiacritic?  (gBehIniRe gBehIniQf)  cNuqtaLikeLower cDiacritic? (gRehFin_jkl cWawFin);


// Don't kern glyphs before the high hamza; retain the space.
cKernable  (gHighHamza gHighHamzaArabic);

// Don't kern before numbers
cKernable  cKernIgnore?  cDigitAbsFullSize;

// For short sequences (two base chars) ending with bariyeh,
// kern against the bariyeh tail, not the initial.
cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags);  // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0, kernLsb + 90m);  // 90m = bariyeh's rsb
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cKernIgnore?  cIni cNuqtaLike? DIACS [cMed cNuqtaLike? DIACS]? 
		gBariyehFin=F;

// Special case: alef + kaf - set them a standard distance apart; don't use auto-kerning mechanism unless
// absolutely necessary.
(gAlef cAlefFin) { shift.x += -130m;
	collision {
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 150m;
		max.x = MAXKERN; min.x = KAFOVERHANG; /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}  /  _  cNuqtaLike?  DIACS  cKernIgnore?  cKafNoIso=K;

// Special case: kaf/jeem + reh-nuqta + beh-isolate
gRehFin_jkl { shift.x += -130m;
	collision {
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 350m;
		max.x = MAXKERN; min.x = KAFOVERHANG; /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}  /  _  cNuqtaLikeUpper?  DIACS  cKernIgnore?  cBehIso=K;


// Don't kern very much before closing quotes.
// PROBLEM: this rule is firing, but the resulting kerning never happens. Why? :-/
// TURN ON FOR BUG:
g_parenleftArab  { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(Q);
	max.x = MAXKERN; min.x = min(0m, pairKern);
}}
	/  _  cNuqtaLike?  DIACS  cQuoteLeftArab=Q;


// Tighten up kerning between full-stop and closing quote.
cFullStop { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 150m;
		max.x = MAXKERN; min.x = -300m;  /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}   /  _  cQuote=Q;

// Omit kerning altogether between punctuation.
cKernPunct { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		flags = SET_KERN(collision.flags);
		margin = 150m;
		max.x = MAXKERN; min.x = 0m; /// MINKERN + minKernDelta;
    	// min/max.y are omitted for kernable glyphs
	}
}   /  _  cKernIgnore?  cKernPunct=P;

// Don't kern underneath a closing quote.
////cKernable { collision.flags = CLEAR_KERN(collision.flags) }
////	/	_  cNuqtaLike?  DIACS  cKernIgnore?  cQuoteLeftArab;

cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(Q);
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} }
	/	_  cNuqtaLike?  DIACS  cKernIgnore?  cQuoteLeftArab=Q;


table(glyph)
cKafNoPreLam = (cKafIni  csKafIni_base  cKafIso);
cKafNoPreLam -= (gKafIni gGafIni);   // remove rounded pre-lam form
endtable;

// Account for overhang of initial kaf diagonal stroke.
cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(N);
	max.x = MAXKERN;
	min.x = min(0m, MINKERN + minKernDelta + KAFOVERHANG
		+ max(0m, 1050m - seqWidth)	// the shorter this sequence, the less kerning we want so it doesn't get lost;
								                // 1050 is somewhat arbitrary but gives the best results (was 1850)
		);
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cKernIgnore?  cKafNoPreLam=N;


// Don't let low punctuation kern very much underneath following segment when preceded by an alef.
#if KERNLOWPUNCT

cLowPunct  { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(N);
	max.x = MAXKERN;
	//min.x = min(0m, -800m + 1250m )   // 800 = 500 + 300; see rule below and minKernDelta for punctuation
	min.x = -1 * advance.x  // arbitrary, seems to work for real-life examples (wide glyphs, eg, full-stop, can kern a bit more)
    // min/max.y are omitted for kernable glyphs
} }
	/  (gAlefFin gAlef) cNuqtaLike?  DIACS  _  cKernIgnore?  cPostKernableNoPunct=N;


#endif  // KERNLOWPUNCT

// Default cases:

cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = SET_MARGIN(N);
	max.x = MAXKERN;
	min.x = min(0m, MINKERN - 500m + minKernDelta    // what is -500???
		+ max(0m, 1250m - seqWidth)   // see above
	);
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cKernIgnore?  cPostKernable=N;

gRehFin  g_bar; // TEMP experiment

cKernable { collision {
	flags = CLEAR_IGNORE(collision.flags); // needed for punctuation
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


/******
endif; // overlapKern == medium

if (overlapKern == tight)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN_TIGHT;
    // min/max.y are omitted for kernable glyphs
} };

endif;
******/

// Digits can kern when they are next to each other.
cDigitAbsFullSize { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN_DIGIT + pairKern;
	max.x = MAXKERN; min.x = MINKERN;
} }  /  _ cDigitAbsFullSize;

// Diacritics aren't affected by the exclusion area above kafs:
cls_excludingGlyphs { collision { flags = CLEAR_FIX(collision.flags); exclude.glyph = 0 }};

// Note that most nuqtas will have been previously marked not-fix, unless they are contiguous to
// height-adjusted kafs.

/////cKernable { collision.flags = CLEAR_FIX(collision.flags) }; - if kerning is done earlier

endpass;  // pos - 11 (18)

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.

if (collFix > 0)
pass(12) { CollisionFix = 4; AutoKern = true }  // 19

// Perform diacritic-related fixing.

endpass;  // 12 (19)
endif;


// Fixes to even up right margin

pass(13)  // 20

gBehIni     {advance.x += 360m}  /  _=B {startOfLine} cNuqtaLike? MARKS cKafMF;

gAlef       {advance.x += 150m}  /  _=A {startOfLine} cNuqtaLike? MARKS (cKafIni cKafIso)=K;

cBariyehFin {advance.x -= 200m}  /  cIni {startOfLine} cNuqtaLike? MARKS  _=By;
cBariyehIso {advance.x -= 200m}  /  _=By {startOfLine};

// Replace these with real glyphs. PDF needs real glyphs.
g__dot2lIM        >  g__dot2l;
g__dot2lIM_small  >  g__dot2l_small;


// Debugger:
//cKernable { user6 = collision.fix.x };

// When there is an overlap, a space should be a little wider. Even more after a full-stop.

cSpace { advance.x += 370m }
	/  cFullStop { collision.fix.x < -400m } MARKS _=S;
cSpace { advance.x += 310m }
	/  cFullStop { collision.fix.x < -300m } MARKS _=S;
cSpace { advance.x += 170m }
	/  cKernable { collision.fix.x < -400m } MARKS _=S;
cSpace { advance.x += 110m }
	/  cKernable { collision.fix.x < -300m } MARKS _=S;

endpass;  // pos - 13


#if KERNLOWPUNCT

if (collFix > 0)
pass(14)  { CollisionFix = 1; AutoKern = true }  // 21

//cLowPunct { collision.margin = 500m; passKeySlot = true } /
//	(gAlefFin gAlef) cNuqtaLike?  DIACS  _ { collision.fix.x < 300m }  cKernIgnore?  cPostKernable=N;

cLowPunct { collision.margin = 330m; passKeySlot = true } /  _ { collision.fix.x < 300m };

// Nothing else needs to be fixed, and we don't want to waste time trying.
cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };
cKernable  { collision.flags = CLEAR_FIX(collision.flags) };

endpass;  // 14
endif;

#endif  // KERNLOWPUNCT


/////#include "awami_tweaks.gdh"

endtable;  // positioning

